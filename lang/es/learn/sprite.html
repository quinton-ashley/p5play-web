<!DOCTYPE html>
<html lang="es" class="es">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>p5play : Sprite</title>
	<link rel="icon" href="/assets/p5play_logo.svg">
	<link rel="stylesheet" href="/learn/style.css">
</head>

<body class="dark">
	<article style="display: none;">
		<nav id="topNav">
			<a href="index.html" class="logoLink active">
				<img alt="p5play logo" src="/assets/p5play_logo.svg" class="p5play_logo">
				<span>p5play</span>
			</a>
			<hr>
			<a href="sprite.html" class="active">Sprite</a>
			<a href="group.html">Group</a>
			<a href="animation.html">Ani</a>
			<a href="input.html">Input</a>
			<a href="camera.html">Camera</a>
			<a href="joints.html">Joints</a>
			<a href="canvas.html">...</a>
			<hr>
			<a id="darkMode" onclick="toggleDarkMode()" tabindex="0" role="button" title="dark mode toggle">
				<div id="darkModeIcon"></div>
			</a>
		</nav>

		<div class="break"></div>

		<div id="page-0" class="page">
			<md id="md0-0">
				<h2 id="configuraci√≥n">Configuraci√≥n</h2>
				<p>El c√≥digo dentro de la funci√≥n <code>setup</code> de <a href="https://q5js.org"
						target="_blank">q5.js</a> (o <a href="https://p5js.org" target="_blank">p5.js</a>) se ejecuta
					cuando comienza el programa. La funci√≥n <code>update</code> se ejecuta 60 veces por segundo por
					defecto.</p>
				<p>El constructor <code>new Canvas()</code> crea una secci√≥n de la pantalla en la que el programa puede
					dibujar.</p>
				<p>¬°Intenta cambiar el ancho y la altura del canvas (los n√∫meros dentro del constructor
					<code>Canvas</code>), luego reinicia el programa de ejemplo!</p>
			</md>
			<script type="mie/p5" id="setup-and-update">
function setup() {
	new Canvas(250, 100);
}

function update() {
	background('blue');
}
			</script>
			<div class="break"></div>
			<md id="md0-1">
				<h2 id="¬øqu√©-es-un-sprite">¬øQu√© es un sprite?</h2>
				<p>¬°Un sprite es un fantasma!</p>
				<p>Los desarrolladores de videojuegos usan la palabra "sprite" para referirse a personajes, objetos, o
					cualquier otra cosa que se mueva sobre un fondo.</p>
				<p>El constructor new Sprite() crea un objeto sprite, el cual contiene variables que definen la
					posici√≥n, tama√±o y apariencia de un sprite.</p>
				<p>¬°Intenta editar las propiedades de los sprites de caja y c√≠rculo en los mini ejemplos a continuaci√≥n!
				</p>
			</md>
			<div class="minis horiz">
				<script type="mie/p5" id="box" base-0="" horiz="" lines="9">
let sprite;

function setup() {
	new Canvas(238, 100);

	sprite = new Sprite();
	sprite.width = 50;
	sprite.height = 50;
}

function update() {
	clear();
}
				</script>
				<script type="mie/p5" id="circle" base-1="" horiz="" lines="8">
let sprite;

function setup() {
	new Canvas(238, 100);

	sprite = new Sprite();
	sprite.diameter = 50;
}

function update() {
	clear();
}
				</script>
			</div>
			<div class="minis">
				<script type="mie/p5" id="x">
sprite.x = 175;
				</script>
				<script type="mie/p5" id="y" base="1">
sprite.y = 30;
				</script>
				<script type="mie/p5" id="color" base="1">
sprite.color = 'pink';
sprite.stroke = 'red';
				</script>
				<script type="mie/p5" id="rotation">
sprite.rotation = 45;
				</script>
			</div>

			<div class="minis">
				<script type="mie/p5" id="width">
sprite.w = 200;
				</script>
				<script type="mie/p5" id="height">
sprite.h = 80;
				</script>
				<script type="mie/p5" id="diameter" base="1">
sprite.d = 40;
				</script>
				<script type="mie/p5" id="textSize">
sprite.textSize = 40;
sprite.text = "p5";
				</script>
			</div>
			<div class="break"></div>
			<div class="minis horiz">
				<md id="md0-2">
					<h2 id="¬°pru√©balo">¬°Pru√©balo!</h2>
					<p>Intenta convertir el sprite llamado <code>ball</code> en un c√≠rculo azul con un di√°metro de 30 y
						col√≥calo en la esquina superior derecha del canvas.</p>
				</md>
				<script type="mie/p5" id="Level-0-Challenge-Solution" hide-editor="">
let ball;

function setup() {
	new Canvas(500, 60);
	ball = new Sprite();
	ball.diameter = 30;
	ball.color = 'blue';
	ball.x = 480;
	ball.y = 16;
}

function update() {
	clear();
}
				</script>
			</div>
			<script type="mie/p5" id="Level-0-Challenge" lines="13" horiz="">
let ball;

function setup() {
	new Canvas(200, 256);
	ball = new Sprite();
	// write your code here!
  
}

function update() {
	clear();
}
			</script>
		</div>
		<div id="page-1" class="page">
			<md id="md1-0">
				<h2 id="f√≠sica-de-los-sprites">F√≠sica de los sprites</h2>
				<p>El colisionador de un sprite se utiliza para detectar colisiones con otros sprites. Por defecto, los
					sprites tienen un colisionador de f√≠sica <code>'dynamic'</code> que permite que el sprite se mueva
					libremente y sea afectado por la gravedad.</p>
				<p>Los colisionadores <code>'static'</code> no pueden moverse. Los colisionadores
					<code>'kinematic'</code> pueden moverse program√°ticamente pero no por otros sprites. Adem√°s, no
					colisionar√°n con otros colisionadores kinem√°ticos. Establecer el tipo de colisionador de un sprite a
					<code>'none'</code> lo elimina de la simulaci√≥n f√≠sica.</p>
				<p>El tipo de colisionador tambi√©n puede establecerse usando la primera letra del nombre del tipo de
					colisionador: <code>'d'</code>, <code>'s'</code>, <code>'k'</code>, o <code>'n'</code>.</p>
				<p>¬°Haz clic en el icono de recargar en la esquina superior derecha de un mini ejemplo para volver a
					reproducirlo!</p>
			</md>
			<script type="mie/p5" id="dynamic-and-static-colliders" base-2="" horiz="" lines="16">
let ball, floor;

function setup() {
	new Canvas(238, 200);
	world.gravity.y = 10;

	ball = new Sprite();
	ball.diameter = 50;
	ball.y = 30;

	floor = new Sprite();
	floor.y = 190;
	floor.w = 238;
	floor.h = 5;
	floor.collider = 'static';
}

function update() {
	clear();
}
			</script>
			<div class="minis">
				<script type="mie/p5" id="anti-gravity" base="2">
world.gravity.y = -1;
				</script>
				<script type="mie/p5" id="sloped-floor" base="2">
floor.rotation = 2;
				</script>
			</div>

			<div class="minis">
				<script type="mie/p5" id="rising-platform" base="2">
floor.collider = 'k';
floor.velocity.y = -1;
				</script>
				<script type="mie/p5" id="whoops!" base="2">
floor.collider = 'none';
				</script>
			</div>
			<div class="break"></div>
			<div class="minis horiz">
				<md id="md1-1">
					<h2 id="¬°pru√©balo">¬°Pru√©balo!</h2>
					<p>Intenta crear un sprite llamado <code>peg</code> con un colisionador est√°tico y forma de c√≠rculo.
						Crea un sprite <code>block</code> con un colisionador din√°mico y forma de caja. Posiciona el
						bloque de modo que golpee el clavo y caiga hacia la derecha.</p>
					<p>Cada vez que la funci√≥n <code>draw</code> de p5.js termina, los sprites se dibujan y actualizan
						autom√°ticamente. Nota que <code>world</code> se crea cuando se carga p5play pero por defecto no
						hay gravedad. Intenta establecer <code>world.gravity.y</code> en un n√∫mero positivo.</p>
					<p>Para un desaf√≠o adicional, intenta restablecer la posici√≥n original del bloque despu√©s de que
						caiga.</p>
				</md>
				<script type="mie/p5" id="Level-1-Challenge-Solution" hide-editor="">
let peg, block;

function setup() {
	new Canvas(460, 60);
	world.gravity.y = 10;

	peg = new Sprite();
	peg.diameter = 10;
	peg.y = 40;
	peg.collider = 'static';

	block = new Sprite();
	block.w = 30;
	block.h = 30;
	block.x = 236;
	block.y = 0;
}

function update() {
	clear();
}
				</script>
			</div>
			<script type="mie/p5" id="Level-1-Challenge" lines="13" horiz="">
let peg, block;

function setup() {
	new Canvas(200, 364);

}

function update() {
	clear();
}
			</script>
		</div>
		<div id="page-2" class="page">
			<md id="md2-0">
				<h2 id="sprites-con-una-imagen">Sprites con una Imagen</h2>
				<p><code>sprite.image</code> (o <code>sprite.img</code>) puede establecerse como un p5.Image o una ruta
					de URL a un archivo de imagen.</p>
				<p>Si necesitas que una imagen se cargue antes de que comience tu programa, es mejor usar <a
						href="https://q5js.org/learn/#loadImage" target="_blank"><code>loadImage</code></a> dentro de la
					funci√≥n <code>preload</code> de p5.js.</p>
				<p><code>sprite.image.offset</code> se puede usar para desplazar la imagen en relaci√≥n con el centro del
					sprite. Esto puede ayudar a alinear mejor la imagen con el colisionador de f√≠sica del sprite.</p>
				<p>Intenta hacer clic en el lienzo de este ejemplo. Cuando la propiedad <code>sprite.debug</code> est√°
					establecida en true, puedes ver el colisionador del cuerpo f√≠sico del sprite.</p>
			</md>
			<script type="mie/p5" id="image">
let monster;

function setup() {
	new Canvas(500, 120);

	monster = new Sprite();
	monster.diameter = 70;
	monster.image = '/learn/assets/monster.webp';
	monster.image.offset.y = 6;
}

function update() {
	clear();
	monster.debug = mouse.pressing();
}
			</script>
			<md id="md2-0-1">
				<p>Establece la <code>opacity</code> (opacidad) de un sprite para cambiar la transparencia de su
					apariencia. Usa un valor entre 0 (completamente transparente) y 1 (completamente opaco).</p>
				<p><code>sprite.image.scale</code> cambia el tama√±o de visualizaci√≥n de la imagen del sprite. El valor
					predeterminado es 1.0. Si la imagen aparece demasiado grande o peque√±a, probablemente debas cambiar
					el tama√±o del archivo de imagen en s√≠ mismo.</p>
			</md>
			<script type="mie/p5" id="opacity">
let star;

function setup() {
	new Canvas(500, 120);

	star = new Sprite();
	star.image = '/learn/assets/star.webp';
}

function update() {
	clear();
	let v = cos(frameCount * 2) * 0.5 + 0.5;
	star.opacity = v;
	star.image.scale = v;
}
			</script>
			<div class="break"></div>
			<md id="md2-1">
				<h2 id="sprites-de-emoji">Sprites de Emoji</h2>
				<p>¬øSin imagen? ü´• ¬°No hay problema! üòÑ</p>
				<p>Puedes usar cualquier emoji como la imagen para tu sprite.</p>
				<p>El tama√±o de la imagen del emoji se basar√° en el tama√±o del sprite.</p>
			</md>
			<script type="mie/p5" id="emoji image" lines="8" horiz="">
function setup() {
	new Canvas(160, 160);

	let painting = new Sprite();
	painting.width = 128;
	painting.height = 128;
	painting.image = 'üñºÔ∏è';
}

function update() {
	noLoop();
}
			</script>
			<div class="break"></div>
			<div class="minis">
				<md id="md2-2">
					<h2 id="arte-de-p√≠xeles">Arte de P√≠xeles</h2>
					<p>Puedes utilizar la funci√≥n <code>spriteArt</code> para crear im√°genes de arte de p√≠xeles para tus
						sprites. Recibe una cadena como entrada y devuelve una imagen. Cada car√°cter en la cadena
						representa el valor de color de un p√≠xel en la imagen.</p>
					<p>El segundo par√°metro de entrada de la funci√≥n <code>spriteArt</code> es la escala de la imagen.
					</p>
				</md>
				<md id="md2-3">
					<h2 id="¬°pru√©balo">¬°Pru√©balo!</h2>
					<p>¬°Intenta crear tu propio arte de p√≠xeles! Echa un vistazo al alfabeto a continuaci√≥n para ver qu√©
						color representa cada letra de forma predeterminada.</p>
				</md>
			</div>
			<script type="mie/p5" id="smiley" lines="15">
let smiley;

function setup() {
	new Canvas(500, 120);
	let smileText = `
..yyyyyy
.yybyybyy
yyyyyyyyyy
yybyyyybyy
.yybbbbyy
..yyyyyy`;

	smiley = new Sprite();
	smiley.img = spriteArt(smileText, 32);
}

function update() {
  noLoop();
}
			</script>
			<div style="width: 100%; padding: 0">
				<script type="mie/p5" id="default-colors" hide-editor="">
function setup() {
	new Canvas(1030, 70);
	let alphaText = `
....b.........d......ff.....h....i...j..k....l...............................t.....................
.aa.bbb.ccc.ddd.ee...f..ggg.hhh.........k.k..l..mmm.nnn.ooo.ppp.qqq.rrr..ss.ttt.u.u.v.v.x.x.y.y.zz
a.a.b.b.c...d.d.ee..fff.ggg.h.h..i...j..kk...l..mmm.n.n.o.o.p.p.q.q.r....s...t..u.u.v.v..x..yyy..z.
.aa.bbb.ccc.ddd.eee..f....g.h.h..i...j..k.k..ll.m.m.n.n.ooo.ppp.qqq.r...ss...tt.uuu..v..x.x...y..zz
........................ggg.........jj......................p.....q.........................yy.....
`;

	let alpha = new Sprite();
	alpha.img = spriteArt(alphaText, 20);

	background(20);
	noLoop();
}

function update() {}

        </script>
			</div>
			<div class="break"></div>
			<md id="md2-4">
				<h2 id="colores-personalizados">Colores Personalizados</h2>
				<p>Tambi√©n puedes crear arte de p√≠xeles que utilice colores personalizados creando una paleta de colores
					y pas√°ndola como tercer par√°metro a la funci√≥n <code>spriteArt</code>.</p>
				<p>Las paletas de colores en p5play deben proporcionarse en formato <a
						href="https://p5js.org/reference/p5/object" target="_blank">Objeto JavaScript</a>. Un objeto JS
					simple es como un diccionario. Puedes definir un color para cada letra que uses en tu arte de
					p√≠xeles. Para crear un color, utiliza la funci√≥n <a href="https://q5js.org/learn/#color"
						target="_blank"><code>color</code></a> de p5.js, que acepta valores RGB (rojo, verde, azul) o
					c√≥digos de color HEX.</p>
				<p>La forma m√°s sencilla de encontrar colores es utilizar un <a
						href="https://www.google.com/search?q=selector+de+colores+google" target="_blank">selector de
						colores</a>.</p>
			</md>
			<script type="mie/p5" id="blue-smiley" lines="20">
let smiley;

function setup() {
	new Canvas(500, 120);
	let smileText = `
..uuuuuu
.uubuubuu
uuuuuuuuuu
uubuuuubuu
.uubbbbuu
..uuuuuu`;

	let palette = {
		u: color(60, 220, 255),
		b: '#303060'
	};

	smiley = new Sprite();
	smiley.img = spriteArt(smileText, 32, palette);
}

function update() {
	noLoop();
}
			</script>
		</div>
		<div id="page-3" class="page">
			<script type="mie/p5" id="idle-player" lines="11" hide="" base-3="">
let player, block;
		
function setup() {
	new Canvas(500, 100);

	player = new Sprite();
	player.x = 400;
	player.diameter = 50;
	player.image = random('üòç ü•∞ üßê ü§ì üòé üòã üòâ ü§© ü•∏ üòØ üòµ‚Äçüí´'.split(' '));

	block = new Sprite();
	// colored box emoji
	block.image = random(['üü•', 'üü¶', 'üü©', 'üü®', 'üüß', 'üü™', 'üü´']);
}

function update() {
	clear();
}
					</script>
			<md id="md3-0">
				<h2 id="movimiento-del-sprite">Movimiento del Sprite</h2>
				<p>Mover un sprite editando directamente sus coordenadas (x, y) lo teletransportar√° a la nueva posici√≥n,
					sin moverlo a trav√©s de posiciones intermedias.</p>
				<p>Prueba haciendo clic en este mini ejemplo.</p>
			</md>
			<script type="mie/p5" id="teleport" base="3">
if (mouse.presses()) {
	player.x = mouse.x;
	player.y = mouse.y;
}
					</script>
			<md id="md3-1">
				<p>Si deseas que un sprite interact√∫e f√≠sicamente con otros sprites mientras se mueve, ¬°no lo
					teletransportes!</p>
				<p>Este mal ejemplo muestra lo que sucede si un sprite es teletransportado cada vez que la funci√≥n de
					dibujo (draw) de p5.js renderiza un fotograma.</p>
			</md>
			<script type="mie/p5" id="teleport-:-continuously-üëé" base="3">
player.x = mouse.x;
player.y = mouse.y;
					</script>
			<md id="md3-2">
				<p>Todos los otros m√©todos de movimiento en esta p√°gina funcionan cambiando las velocidades de los ejes
					x e y del sprite. <code>velocity</code> tambi√©n conocida como <code>vel</code> es un Vector de
					p5.js, puedes usar cualquier funci√≥n de Vector en √©l.</p>
				<p>Puede que tengas que reiniciar este ejemplo para ver moverse al sprite.</p>
			</md>
			<script type="mie/p5" id="velocity-:-continuously" base="3">
player.vel.x = -2;
player.vel.y = 0.1;
					</script>
			<md id="md3-3">
				<p>Mueve el sprite indefinidamente estableciendo su <code>direction</code> y <code>speed</code>.</p>
				<p>Tambi√©n puedes establecer la direcci√≥n de un sprite usando un nombre de direcci√≥n como: 'up', 'down',
					'left', 'right', 'upLeft', 'upRight', 'downLeft', 'downRight'.</p>
				<p>Nota que p5play convierte estos nombres de direcci√≥n a sus correspondientes valores de √°ngulo.</p>
			</md>
			<script type="mie/p5" id="direction-+-speed-:-continuously" base="3">
player.direction = 187;
player.speed = 3;
					</script>
			<md id="md3-4">
				<p>La funci√≥n <code>move</code> mueve un sprite a trav√©s de una distancia fija. La direcci√≥n y la
					velocidad del movimiento pueden especificarse como par√°metros de la funci√≥n o establecerse por
					separado.</p>
			</md>
			<script type="mie/p5" id="move-:-impulse" base="3">
if (kb.presses('left')) {
	//   (distance, direction, speed)
	player.move(30, 'left', 3);
}
					</script>
			<md id="md3-5">
				<p>La funci√≥n <code>moveTowards</code> mueve un sprite hacia una posici√≥n, a un porcentaje de la
					distancia a esa posici√≥n.</p>
				<p>En este ejemplo, el jugador se mueve el 10% de la distancia al rat√≥n en cada llamada de dibujo de
					p5.js. Su velocidad, y la fuerza que ejerce sobre el bloque, es proporcional a la distancia que se
					mueve.</p>
			</md>
			<script type="mie/p5" id="moveTowards-:-continuously" base="3">
//                (x, y, tracking)
//                (position, tracking)
player.moveTowards(mouse, 0.10);
					</script>
			<md id="md3-6">
				<p>La funci√≥n <code>moveTo</code> genera un impulso que mueve un sprite a una posici√≥n a una velocidad
					constante.</p>
				<p>Pero ten en cuenta que si el sprite es actuado por una fuerza como la gravedad o choca con otro
					sprite, su velocidad y direcci√≥n se ver√°n afectadas y puede que no llegue a la posici√≥n objetivo.
				</p>
				<p>Cualquier funci√≥n de movimiento que acepte un objeto con propiedades x e y podr√≠a en su lugar ser
					llamada con n√∫meros de posici√≥n (x, y).</p>
			</md>
			<script type="mie/p5" id="moveTo-:-impulse" base="3">
if (mouse.presses()) {
	//           (x, y, speed)
	//           (position, speed)
	player.moveTo(mouse.x, mouse.y, 8);
}
					</script>
			<md id="md3-7">
				<p>Esperamos que los ejemplos en esta p√°gina te ayuden a entender algunas de las opciones de movimiento
					disponibles en p5play.</p>
				<p>Ten en cuenta que las funciones move, moveTo y moveTowards anulan el movimiento actual de un sprite,
					oblig√°ndolo a moverse en una nueva direcci√≥n. ¬°Eso podr√≠a no ser siempre lo que quieres!</p>
				<p>Para aprender m√°s sobre el movimiento de sprites, lee las p√°ginas de "Secuenciaci√≥n de Movimientos" y
					"Movimiento Avanzado".</p>
			</md>
			<script type="mie/p5" id="segmented-motion" base="3">
if (kb.pressing('left')) player.vel.x = -5;
else if (kb.pressing('right')) player.vel.x = 5;
else player.vel.x = 0;
			</script>
		</div>
		<div id="page-4" class="page">
			<div class="minis horiz">
				<md id="md4-0">
					<h2 id="crea-sprites-m√°s-r√°pido">Crea Sprites m√°s r√°pido</h2>
					<p>Dentro del constructor de Sprite, <code>new Sprite()</code>, puedes especificar la posici√≥n, el
						tama√±o y el tipo de colisionador del sprite.</p>
					<p>Como viste en las p√°ginas de referencia de Sprite anteriores, no necesitas agregar ninguna
						entrada al constructor de Sprite para crear un sprite. Pero si quieres establecer el tama√±o de
						un sprite en el constructor, necesitar√°s especificar su posici√≥n primero.</p>
					<p>Por defecto, si no se dan entradas al constructor de Sprite, los nuevos sprites se posicionan en
						el centro del lienzo, con un ancho y altura de 50 p√≠xeles, y un colisionador din√°mico.</p>
				</md>
				<script type="mie/p5" id="default-sprite" lines="5" horiz="">
function setup() {
	new Canvas(100, 100);

	new Sprite();
}

function update() {}
				</script>
			</div>
			<div class="minis horiz">
				<script type="mie/p5" id="Ooo!" horiz="" lines="18">
let box, circle;

function setup() {
	new Canvas(50, 200);
	world.gravity.y = 10;

	//             	( x,  y,  w,  h, collider)
	box = new Sprite(25, 70, 10, 90, 'static');
	// same as setting the values separately
	// box.x = 25;
	// box.y = 70;
	// box.width = 10;
	// box.height = 90;
	// box.collider = 'static';

	// 					 	     ( x,   y,  d, collider)
	circle = new Sprite(25, 140, 10, 'static');
}

function update() {
	clear();
}
				</script>
				<script type="mie/p5" id="ball-on-the-floor" lines="10" horiz="">
let ball, floor;

function setup() {
	new Canvas(80, 160);
	world.gravity.y = 10;
	
	ball = new Sprite(40, 30, 50);

	floor = new Sprite(40, 155, 80, 5, 'static');
}

function update() {
	clear();
}
				</script>
			</div>
			<div class="break"></div>
			<md id="md4-1">
				<h2 id="¬°pru√©balo">¬°Pru√©balo!</h2>
				<p>Intenta crear dos sprites usando el constructor de sprite.</p>
			</md>
			<script type="mie/p5" id="Level-4-Challenge" lines="13" horiz="">
let sprite1, sprite2;

function setup() {
	new Canvas(50, 256);

}

function update() {
	clear();
}
			</script>
		</div>
		<div id="page-5" class="page">
			<md id="md5-0">
				<h2 id="colisiones">Colisiones</h2>
				<p>En el primer fotograma en que un sprite colisiona con otro sprite, la funci√≥n <code>collides</code>
					devuelve true.</p>
				<p>Mientras un sprite est√° colisionando con otro sprite, la funci√≥n <code>colliding</code> devuelve el
					n√∫mero de fotogramas que ha ocurrido la colisi√≥n.</p>
				<p>En el primer fotograma despu√©s de que dos sprites colisionaron, la funci√≥n <code>collided</code>
					devuelve true.</p>
			</md>
			<script type="mie/p5" id="pillar-stomp!" horiz="">
let player, pillar;

function setup() {
	new Canvas(60, 342);
	world.gravity.y = 10;
	
	pillar = new Sprite(30, 362, 30, 500, 'static')
	player = new Sprite(30, 0, 50);
}

function update() {
	clear();

	if (player.collides(pillar)) {
		player.vel.y = -5;
		pillar.h -= 52;
	}
}
			</script>
			<script type="mie/p5" id="drop-block" horiz="">
let block, floor;

function setup() {
	new Canvas(60, 342);
	world.gravity.y = 10;
	
	block = new Sprite(30, 30);
	floor = new Sprite(30, 300, 60, 5, 'static');
	floor.color = 'red';
}

function update() {
	clear();
	if (block.colliding(floor)) {
		block.color = 'red';
	} else block.color = 'blue';

	if (block.colliding(floor) > 60) {
		block.vel.y = -9;
	}
}
			</script>
			<script type="mie/p5" id="break-floor" horiz="">
let block, floor;

function setup() {
	new Canvas(60, 342);
	world.gravity.y = 10;
	
	block = new Sprite(30, 30);
	floor = new Sprite(30, 300, 60, 5, 'static');
}

function update() {
	clear();
	if (block.collided(floor)) {
		floor.collider = 'dynamic';
	}
}
			</script>
		</div>
		<div id="page-6" class="page">
			<md id="md6-0">
				<h2 id="superposiciones">Superposiciones</h2>
				<p>¬°Los sprites colisionan por defecto, pero tambi√©n pueden superponerse!</p>
			</md>
			<script type="mie/p5" id="overlap" horiz="" lines="8" base-4="">
function setup() {
	new Canvas(180, 128);

	spriteA = new Sprite(80, 50);
	spriteB = new Sprite(105, 75);

	spriteA.overlaps(spriteB);
}

function update() {
	clear();
}
			</script>
			<md id="md6-1">
				<h2 id="capa">Capa</h2>
				<p>Por defecto, los sprites se dibujan en el orden en que fueron creados. Puedes cambiar el orden de
					dibujo editando la propiedad <code>.layer</code> del sprite. Los sprites con el valor de capa m√°s
					alto se dibujan primero.</p>
			</md>
			<script type="mie/p5" id="layer" horiz="" lines="8" base="4">
spriteA.layer = 2;
spriteA.text = 'Layer 2';

spriteB.layer = 1;
spriteB.text = 'Layer 1';
			</script>
			<md id="md6-2">
				<p>En el primer fotograma en que un sprite se superpone con otro sprite, la funci√≥n
					<code>overlaps</code> devuelve true.</p>
				<p>Mientras un sprite se superpone con otro sprite, la funci√≥n <code>overlapping</code> devuelve el
					n√∫mero de fotogramas que ha ocurrido la superposici√≥n.</p>
				<p>En el primer fotograma despu√©s de que dos sprites se superpongan, la funci√≥n <code>overlapped</code>
					devuelve true.</p>
				<p>Ten en cuenta que las interacciones f√≠sicas entre sprites, incluyendo colisiones y superposiciones,
					no pueden detectarse correctamente cuando un sprite es teletransportado, ¬°su posici√≥n cambia
					directamente!</p>
			</md>
			<script type="mie/p5" id="collect-coin">
let player, coin;

function setup() {
	new Canvas(500, 100);

	coin = new Sprite(400, 50, 30);
	coin.color = 'yellow';
	player = new Sprite(50, 50);
}

function update() {
	clear();
	player.moveTowards(mouse);
		
	if (player.overlaps(coin)) coin.remove();
}
			</script>
			<div class="break"></div>
			<md id="md6-3">
				<h2 id="¬°pru√©balo">¬°Pru√©balo!</h2>
				<p>Intenta hacer que el sprite azul cambie a rojo solo si se superpone con el sprite rojo.</p>
			</md>
			<script type="mie/p5" id="Level-6-Challenge" lines="20" horiz="">
let sprite1, sprite2;

function setup() {
	new Canvas(100, 400);

	sprite1 = new Sprite(50, 50);
	sprite1.color = 'blue';

	sprite2 = new Sprite(50, 300);
	sprite2.color = 'red';
}

function update() {
	clear();
	sprite1.moveTowards(mouse);

	
	
}
			</script>
			<div class="break"></div>
			<md id="md6-4">
				<h2 id="cambiar-entre-superposiciones-y-colisiones">Cambiar entre superposiciones y colisiones</h2>
				<p>Por defecto, si compruebas si hay una superposici√≥n entre dos sprites, ya no colisionar√°n. Puedes
					anular esto comprobando si hay una colisi√≥n entre los sprites.</p>
				<p>En este ejemplo, al presionar la tecla de espacio se permite temporalmente al jugador atravesar la
					pared como un fantasma.</p>
			</md>
			<script type="mie/p5" id="ghost-ability">
let player, wall;

function setup() {
	new Canvas(500, 100);

	wall = new Sprite(250, 50, 30, 400, 's');
	wall.color = 'purple';
	player = new Sprite(50, 50);
}

function update() {
	clear();
	player.moveTowards(mouse);

	if (kb.pressing('space')) {
		player.overlaps(wall);
		player.color = 'purple';
	} else {
		player.collides(wall);
		player.color = 'orange';
	}
}

			</script>
		</div>
		<div id="page-7" class="page">
			<script type="mie/p5" base-5="" hide="">
let sprite;

function setup() {
	new Canvas(60, 80);

	sprite = new Sprite();
	sprite.h = 20;
}

function update() {
	clear();
}
			</script>
			<script type="mie/p5" base-8="" hide="">
let sprite;

function setup() {
	new Canvas(500, 80);

	sprite = new Sprite();
	sprite.h = 20;
}

function update() {
	clear();
}
			</script>
			<md id="md7-0">
				<h2 id="rotaci√≥n-de-sprite">Rotaci√≥n de Sprite</h2>
				<p>Cambiar directamente la propiedad <code>rotation</code> de un sprite lo teletransportar√° al √°ngulo de
					rotaci√≥n especificado.</p>
				<p>¬°No teletransportes un sprite si quieres que interact√∫e f√≠sicamente con otros sprites mientras est√°
					rotando!</p>
			</md>
			<script type="mie/p5" id="rotation-(teleport)" base="5">
if (kb.pressing('space')) sprite.rotation = 90;
else sprite.rotation = 0;
			</script>
			<md id="md7-1">
				<p>Todos los otros m√©todos de rotaci√≥n en esta p√°gina funcionan cambiando la <code>rotationSpeed</code>
					del sprite.</p>
			</md>
			<script type="mie/p5" id="rotationSpeed" base="5">
sprite.rotationSpeed = 1;
			</script>
			<md id="md7-2">
				<p>Usa la funci√≥n <code>rotate</code> para rotar un sprite una cantidad.</p>
				<p>El segundo par√°metro opcional es la velocidad a la que rota el sprite por fotograma.</p>
			</md>
			<script type="mie/p5" id="rotate" base="5">
//                              (angle, rotationSpeed)
if (kb.presses('space')) sprite.rotate(15, 3);
			</script>
			<md id="md7-3">
				<p>Use la funci√≥n <code>rotateTo</code> para rotar un sprite a un √°ngulo o para enfrentar una posici√≥n.
					La funci√≥n <code>rotateMinTo</code> cambia el signo de la velocidad de rotaci√≥n del sprite si es
					necesario para rotar el sprite la distancia angular m√≠nima para enfrentar el √°ngulo de destino. El
					√°ngulo de "facing", un tercer par√°metro opcional, es el √°ngulo al que el sprite deber√≠a estar cuando
					enfrenta la posici√≥n objetivo.</p>
				<p>Intente cambiar el √°ngulo de enfrentamiento de 0 a 90 en el ejemplo de c√≥digo. Luego, cuando haga
					clic, el lado largo del sprite se rotar√° para enfrentar el rat√≥n.</p>
			</md>
			<div class="minis horiz">
				<script type="mie/p5" id="rotateTo-(an-angle)" base="5">
//                               (angle, rotationSpeed)
if (kb.presses('left')) sprite.rotateTo(-90, 5);
if (kb.presses('right')) sprite.rotateTo(0, 5);
				</script>
				<script type="mie/p5" id="rotateMinTo-(face-a-position)" base="8">
//                              (pos, speed, facing)
if (mouse.presses()) sprite.rotateMinTo(mouse, 5, 0);
				</script>
			</div>
			<md id="md7-4">
				<p>Usa la funci√≥n <code>rotateTowards</code> para girar un sprite hacia un √°ngulo o hacia una posici√≥n.
				</p>
				<p>El segundo par√°metro opcional es la velocidad de seguimiento, un porcentaje de la distancia que el
					sprite se mueve en cada fotograma al √°ngulo de rotaci√≥n objetivo, 0.1 (10%) por defecto.</p>
			</md>
			<script type="mie/p5" id="rotateTowards" base="5">
//           (position, tracking, facing)
sprite.rotateTowards(mouse, 0.1, 0);
			</script>
			<md id="md7-5">
				<p>Usa la propiedad <code>offset</code> para mover el cuerpo f√≠sico del sprite en relaci√≥n con su
					centro.</p>
				<p>Cuando <code>sprite.debug</code> es true, el centro del sprite est√° marcado con una peque√±a cruz
					verde. El punto central es donde se encuentran las coordenadas x e y del sprite. Tambi√©n es el
					centro de rotaci√≥n.</p>
			</md>
			<script type="mie/p5" id="offset">
function setup() {
	new Canvas(500, 200);

	let flipper = new Sprite(250, 100, 200, 20, 'k');
	flipper.debug = true;
	flipper.rotationSpeed = 1;
	flipper.offset.x = 40;
}

function update() {
	clear();
	if (mouse.presses()) new Sprite(mouse.x, mouse.y, 10);
}

			</script>
		</div>
		<div id="page-8" class="page">
			<md id="md8-0">
				<h2 id="secuenciaci√≥n-de-movimientos">Secuenciaci√≥n de movimientos</h2>
				<p>Estos ejemplos utilizan un sprite <code>Turtle</code> que es simplemente un sprite regular
					que es verde y tiene forma de tri√°ngulo para ese aspecto cl√°sico de la
					programaci√≥n de tortugas.</p>
				<p>Puedes usar la palabra clave <code>await</code> dentro de una funci√≥n <code>async</code> para esperar
					a que un movimiento termine antes de continuar con el siguiente movimiento. Esto es √∫til para hacer
					que un sprite se mueva en secuencia.</p>
			</md>
			<script type="mie/p5" id="scaling">
let sprite;

function setup() {
	new Canvas(500, 200);

	sprite = new Sprite(250, 100, 90, 90);
	sprite.img = '/learn/assets/square.webp';
	sprite.debug = true;
}

function update() {
	clear();

	for (let i = 1; i < 10; i++) {
		if (kb.presses(i)) sprite.scale = i;
	}

	if (mouse.presses()) sprite.scale *= 2;
	if (kb.presses('x')) sprite.scale.x = random(0.1, 6);
	if (kb.presses('y')) sprite.scale.y = random(0.1, 6);

	if (kb.pressing('a')) sprite.img.scale.x = 10;
	else sprite.img.scale.x = 1;
}
			</script>
		</div>
		<div id="page-9" class="page">
			<md id="md9-0">
				<h2 id="atributos-f√≠sicos">Atributos f√≠sicos</h2>
				<p>Los Sprites tienen atributos f√≠sicos que afectan c√≥mo interact√∫an con el mundo. Echa un vistazo a los
					mini-ejemplos para ver estos atributos en acci√≥n.</p>
			</md>
			<script type="mie/p5" base-6="" hide="">
let sprite, floor;
function setup() {
	new Canvas(238, 100);
	world.gravity.y = 10;
	sprite = new Sprite(26, 0, 40, 40);
	floor = new Sprite(119, 88, 238, 5, 's');
	floor.rotation = 5;
}
function update() {
	clear();
}
			</script>
			<script type="mie/p5" base-7="" hide="">
let sprite, floor;
function setup() {
	new Canvas(238, 100);
	world.gravity.y = 10;
	sprite = new Sprite(26, 0, 40);
	floor = new Sprite(119, 88, 238, 5, 's');
	floor.rotation = 5;
}
function update() {
	clear();
}
			</script>
			<div class="minis">
				<script type="mie/p5" id="low-bounciness" base="7">
sprite.bounciness = 0.5;
				</script>
				<script type="mie/p5" id="full-bounciness" base="7">
sprite.bounciness = 1;
				</script>
			</div>
			<div class="minis">
				<script type="mie/p5" id="0-friction" base="6">
sprite.friction = 0;
				</script>
				<script type="mie/p5" id="high-friction" base="6">
sprite.friction = 10;
				</script>
				<script type="mie/p5" id="0-drag" base="6">
sprite.drag = 0;
				</script>
				<script type="mie/p5" id="high-drag" base="6">
sprite.drag = 10;
				</script>
			</div>
			<div class="minis">
				<script type="mie/p5" id="low-rotationDrag" base="7">
sprite.rotationDrag = 1;
				</script>
				<script type="mie/p5" id="high-rotationDrag" base="7">
sprite.rotationDrag = 5;
				</script>
				<script type="mie/p5" id="no-rotationLock" base="7">
sprite.rotationLock=false
				</script>
				<script type="mie/p5" id="with-rotationLock" base="7">
sprite.rotationLock =true
				</script>
			</div>
			<div class="break"></div>
			<div class="minis horiz">
				<md id="md9-1">
					<h2 id="masa">Masa</h2>
					<p>Por defecto, la <code>mass</code> se asigna en funci√≥n del tama√±o del sprite. Cuanto mayor sea el
						sprite, m√°s masa tendr√°. La masa tambi√©n puede ser ajustada manualmente.</p>
				</md>
				<md id="md9-2">
					<h2 id="¬°pru√©balo">¬°Pru√©balo!</h2>
					<p>Intenta cambiar la masa de uno de los sprites en este mini ejemplo.</p>
				</md>
			</div>
			<script type="mie/p5" id="mass" lines="15">
let platform, pin, spriteA, spriteB;

function setup() {
	new Canvas(300, 100);
	world.gravity.y = 10;

	platform = new Sprite(150, 88, 232, 5);
	pin = new Sprite(150, 93, 5, 's');

	spriteA = new Sprite(50, 0, 80, 40);
	spriteA.mass = 2;

	spriteB = new Sprite(250, 0, 20, 40);
	spriteB.mass = 2;
}

function update() {
	clear();
}
			</script>
			<div class="break"></div>
			<md id="md9-3">
				<h2 id="bugs-en-planck">Bugs en planck</h2>
				<p>p5play usa el motor de f√≠sica planck, que normalmente ofrece interacciones f√≠sicas de apariencia
					realista, pero no es perfecto.</p>
				<p>En este mini-ejemplo, la bola tiene una <code>bounciness</code> de 1, as√≠ que cada vez que la bola
					rebota deber√≠a volver a su posici√≥n inicial. Sin embargo, debido a un bug en planck, la bola rebota
					cada vez m√°s alto cada vez que golpea el suelo.</p>
			</md>
			<script type="mie/p5" id="full-bounce-error" lines="10" horiz="">
let ball, ground;
function setup() {
	new Canvas(32, 192);
	world.gravity.y = 10;

	ball = new Sprite(16, 100, 8);
	ball.bounciness = 1;

	ground = new Sprite(16, 184, 32, 16, 's');
}

function update() {
	background(0);

	fill(100);
	for (let i = 0; i < width / 32; i++) {
		for (let j = 0; j < height / 32; j++) {
			rect(i * 32, j * 32, 32, 32);
		}
	}
}
			</script>
			<md id="md9-4">
				<p>Esperemos que el bug se solucione en una futura versi√≥n de planck o p5play, pero hasta entonces aqu√≠
					tienes una soluci√≥n alternativa.</p>
				<p>El bug de <code>bounciness</code> es m√°s notorio cuando un colisionador rebota en una superficie
					plana. Aqu√≠ tienes una soluci√≥n alternativa que sobrescribe la velocidad y de la bola despu√©s de que
					colisiona con el suelo.</p>
			</md>
			<script type="mie/p5" id="full-bounce-workaround" horiz="">
let ball, ground;
function setup() {
	new Canvas(32, 192);
	world.gravity.y = 10;

	ball = new Sprite(16, 100, 8);
	ball.bounciness = 1;

	ground = new Sprite(16, 184, 32, 16, 's');
}

function update() {
	clear();

	if (ball.collided(ground)) {
		ball.vel.y = -4.8;
	}
}
			</script>
			<md id="md9-5">
				<p>En este ejemplo, el color del bloque es rojo cuando est√° colisionando con la plataforma m√≥vil. Aunque
					podr√≠as esperar que el bloque se mantenga rojo mientras est√° siendo levantado por la plataforma,
					parpadea entre rojo y azul.</p>
				<p>En la vida real, cuando una persona sube a un ascensor y este sube, dir√≠amos que esa persona estar√≠a
					colisionando con el suelo del ascensor durante todo el trayecto.</p>
				<p>En planck, sin embargo, cuando los colisionadores son desplazados por otros colisionadores,
					constantemente colisionan y dejan de colisionar entre s√≠.</p>
				<p>Si est√°s intentando hacer un juego de plataformas (como Super Mario Bros.), el 'colliding' no es una
					manera confiable de verificar si un sprite est√° parado en una plataforma. Echa un vistazo a mi <a
						href="https://openprocessing.org/sketch/1869796" target="_blank">demostraci√≥n de
						plataformas</a>.</p>
			</md>
			<script type="mie/p5" id="displacement" horiz="">
let block, platform;

function setup() {
	new Canvas(60, 400);
	world.gravity.y = 10;

	block = new Sprite(30, 30);
	platform = new Sprite(30, 200, 60, 5, 'k');
	platform.color = 'red';
}

function update() {
	clear();
	platform.vel.y = cos(frameCount * 2.2) * 6;

	if (block.colliding(platform)) {
		block.color = 'red';
	} else {
		block.color = 'blue';
	}
}

			</script>
		</div>
		<div id="page-10" class="page">
			<md id="md10-0">
				<h2 id="colisionadores-de-cadena">Colisionadores de Cadena</h2>
				<p>Hay tres modos de cadena diferentes: v√©rtice, distancia y l√≠nea.</p>
				<p>Para usar el modo v√©rtice, proporciona al constructor Sprite un array de arrays de v√©rtices. Cada
					array de v√©rtices debe contener coordenadas [x, y]. En estos mini-ejemplos, la posici√≥n (x, y) del
					sprite est√° resaltada por un peque√±o cuadrado negro.</p>
				<p>¬°Intenta cambiar los v√©rtices del sprite de cadena en el mini-ejemplo para que la bola se quede en el
					suelo!</p>
			</md>
			<script type="mie/p5" id="applyForce" horiz="">
let drone, floor;

function setup() {
	new Canvas(100, 500);
	world.gravity.y = 4;

	drone = new Sprite(50, 0, 40, 10);
	
	floor = new Sprite(50, 498, 100, 6, 's');
}

function update() {
	background(16);

	if (mouse.pressing()) {
		drone.bearing = -90;
		drone.applyForce(6);
	}
}
			</script>
			<md id="md10-1">
				<p>Para usar el modo distancia, proporciona al constructor Sprite una posici√≥n (x, y) y un array de
					arrays de distancia. Estos arrays deben contener distancias [x, y] relativas al v√©rtice anterior. La
					posici√≥n (x, y) ser√° el primer v√©rtice de la cadena.</p>
				<p>El modo distancia es el mejor para crear cadenas s√∫per largas.</p>
				<p>Intenta a√±adir 5 distancias para hacer que el suelo suba y baje en una cadena de suelo rocoso.</p>
			</md>
			<script type="mie/p5" id="applyForceScaled" horiz="">
let s0, s1;
function setup() {
  new Canvas(100, 288);
  s0 = new Sprite(51, 252, 20, 20);
	s1 = new Sprite(49, 32, 20, 20);
	new Sprite(50, 4, 100, 8, 's');
  new Sprite(50, 284, 100, 8, 's');
}

function update() {
  background(16);
	//                 (x,  y)
	s0.applyForceScaled(0, -10);
	s1.applyForceScaled(0, 10);
}
      </script>
			<md id="md10-2">
				<p>Para usar el modo l√≠nea, proporciona al constructor Sprite una posici√≥n (x,y) y una lista de
					longitudes de l√≠nea y √°ngulos. Cada √°ngulo es relativo al √°ngulo de la l√≠nea anterior.</p>
				<p>Es mejor usar el modo l√≠nea para cadenas peque√±as y/o sim√©tricas.</p>
				<p>Nota que la posici√≥n (x, y) de la cadena del modo l√≠nea se ubica en el promedio de todos sus
					v√©rtices, lo cual puede no ser un punto en la cadena.</p>
				<p>¬°Intenta cambiar las longitudes de estas l√≠neas y sus √°ngulos!</p>
			</md>
			<script type="mie/p5" id="attractTo">
let nucleus, electron;

function setup() {
	new Canvas(500, 200);
	nucleus = new Sprite(250, 100, 45);
	electron = new Sprite(150, 100, 10);
	electron.vel.y = 5;
}

function update() {
	background(16, 10);
	//               (position, force)
	electron.attractTo(nucleus, 5);
}
			</script>
			<md id="md10-3">
				<p>Torque is the force that causes rotation. Use <code>applyTorque</code> to non-imperatively affect the
					sprite's rotation.</p>
				<p>In this example, the robot rolls slower going uphill than it does going downhill.</p>
			</md>
			<script type="mie/p5" id="applyTorque">
let robot, floor1, floor2;

function setup() {
	new Canvas(500, 250);
	world.gravity.y = 10;

	robot = new Sprite(250, 0, 50);
	robot.debug = true;

	floor1 = new Sprite(400, 100, 500, 5, 's');
	floor1.rotation = -10;
	floor2 = new Sprite(890, 100, 500, 5, 's');
	floor2.rotation = 10;
}

function update() {
	background(16);
	
	robot.applyTorque(3);

	camera.pos = robot.pos;
}
			</script>
		</div>
		<div id="page-11" class="page">
			<md id="md11-0">
				<h2 id="colisionadores-de-pol√≠gonos">Colisionadores de Pol√≠gonos</h2>
				<p>Los pol√≠gonos regulares pueden crearse proporcionando al constructor Sprite una longitud de lado y el
					nombre del pol√≠gono.</p>
				<p>Estos son los nombres que puedes usar: tri√°ngulo, cuadrado, pent√°gono, hex√°gono, sept√°gono, oct√°gono,
					ene√°gono, dec√°gono, hendec√°gono y dodec√°gono.</p>
			</md>
			<script type="mie/p5" id="vertex-mode" lines="12">
let floor, ball;

function setup() {
	new Canvas(500, 200);
	world.gravity.y = 10;

	//                ([vertex0, vertex1, vertex2, ...])
	floor = new Sprite([[20, 60], [200, 140], [450, 180]]);
	floor.collider = 'static';

	ball = new Sprite(40, 0, 20);
}

function update() {
	clear();
	rect(floor.x - 2, floor.y - 2, 4, 4);
}
			</script>
			<md id="md11-1">
				<p>Si el inicio y el final de una cadena est√°n en el mismo punto y la forma resultante es convexa, ¬°se
					convierte autom√°ticamente en un pol√≠gono!</p>
			</md>
			<script type="mie/p5" id="distance-mode" lines="9">
function setup() {
	new Canvas(500, 100);
	world.gravity.y = 10;

	//        ( x,  y, [distance0, distance1, ...])
	new Sprite(30, 50, [[60, 20], [90, -9], [90, 9]], 's');

	new Sprite(40, 0, 20);
}
	
function update() {
	clear();
	rect(allSprites[0].x - 2, allSprites[0].y - 2, 4, 4);
}
			</script>

			<md id="md11-2">
				<p>Independientemente de si un sprite es un pol√≠gono o una cadena, todos los cuerpos f√≠sicos que
					comienzan y terminan en el mismo punto tienen su posici√≥n (x, y) ubicada en el centro de la forma,
					no en el primer v√©rtice. Esta posici√≥n se calcula promediando todos los v√©rtices de la forma.</p>
			</md>
			<script type="mie/p5" id="line-mode" lines="9">
function setup() {
	new Canvas(500, 200);
	world.gravity.y = 10;

	//        (  x,   y, [length0, angle0, length1, ...])
	new Sprite(250, 100, [50, 20, 50, -20, 50, -20], 's');

	new Sprite(200, 0, 20);
}
	
function update() {
	clear();
	rect(allSprites[0].x - 2, allSprites[0].y - 2, 4, 4);
}
			</script>
		</div>
		<div id="page-12" class="page">
			<md id="md12-0">
				<h2 id="dibujo-personalizado">Dibujo personalizado</h2>
				<p>A veces no podr√°s usar animaciones predibujadas para obtener el tipo de efecto visual que quieres
					para un sprite en movimiento.</p>
				<p>Afortunadamente, puedes personalizar la funci√≥n <code>draw</code> del sprite y hacer que muestre
					cualquier cosa que quieras!</p>
				<p>Ten en cuenta que dentro de la funci√≥n de dibujo del sprite, el centro del sprite se traduce a la
					posici√≥n (0, 0).</p>
				<p>Este mini ejemplo rota la elipse del sprite en la direcci√≥n en la que se est√° moviendo y hace que la
					elipse se estire en esa direcci√≥n proporcionalmente a su velocidad. ¬°Un poco complicado!</p>
			</md>
			<script type="mie/p5" id="pentagon" lines="6">
function setup() {
	new Canvas(500, 100);

	//        ( x,  y, sideLength, polygonName)
	new Sprite(250, 50, 50, 'pentagon');
}
	
function update() {
	clear();
}
			</script>
			<md id="md12-1">
				<h2 id="actualizaci√≥n-personalizada">Actualizaci√≥n personalizada</h2>
				<p>Tambi√©n puedes definir una funci√≥n <code>update</code> de actualizaci√≥n personalizada para un sprite
					que se ejecuta al final del bucle de dibujo o cuando se llama a updateSprites. Puedes poner
					cualquier comportamiento espec√≠fico del sprite que quieras all√≠.</p>
			</md>
			<script type="mie/p5" id="irregular-polygon:-vertex-mode" lines="5">
function setup() {
	new Canvas(500, 100);

	new Sprite([[8, 8], [140, 92], [300, 40], [8, 8]]);
}

function update() {
	clear();
}
			</script>
			<md id="md12-2">
				<p>You can force a convex polygon to be a chain by setting <code>sprite.shape = 'chain'</code></p>
			</md>
			<script type="mie/p5" id="box-chain" lines="6" horiz="">
function setup() {
	new Canvas(150, 100);

	let s = new Sprite(75, 50, 100, 60);
	s.shape = 'chain';
}
	
function update() {
	clear();
}
			</script>
			<md id="md12-3">
				<p>Any polygon or chain with a closed shape is center positioned.</p>
			</md>
			<script type="mie/p5" id="irregular-polygon:-distance-mode" lines="9" horiz="">
function setup() {
	new Canvas(250, 100);

	new Sprite(125, 50, [
		[100, 40],
		[-100, 40],
		[0, -80]
	]);
}

function update() {
	clear();
}
			</script>
			<md id="md12-4">
				<p>Here's the code for making a regular star with five points.</p>
				<p>Note that because the star is a concave shape it can't have a polygon collider.</p>
			</md>
			<script type="mie/p5" id="star" lines="6">
function setup() {
	new Canvas(500, 160);

	//        ( x,  y, [l0, a0, l1, a1, repeat])
	new Sprite(250, 80, [50, -72, 50, 144, 5]);
}

function update() {
	clear();
}
			</script>
			<md id="md12-5">
				<p>Now you can see how the tumbler demo on the p5play homepage was made!</p>
				<p>Closed chains are empty on the inside and they can act as a container for many smaller sprites.</p>
			</md>
			<script type="mie/p5" id="p5play-logo" lines="8">
function setup() {
	new Canvas(500, 180);
	world.gravity.y = 10;

	new Sprite(250, 90, [40, 72, 40, -72, 40, 72, 5], 's');

	new Sprite(251, 50, 20, 'pentagon');
}

function update() {
	clear();
}
			</script>
			<md id="md12-6">
				<p>Note that closed chain colliders aren't so good at being dynamic colliders.</p>
				<p>This is a limitation of the Box2D physics engine that p5play uses. See the "Combo Colliders" page to
					learn how to create concave colliders from multiple convex colliders.</p>
			</md>
			<script type="mie/p5" id="concave-chain-colliders" lines="11">
function setup() {
	new Canvas(500, 100);
	world.gravity.y = 10;

	new Sprite([
		[200, 0],
		[300, 0],
		[300, 50],
		[280, 20],
		[200, 0]
	]);

	new Sprite(250, 90, 500, 10, 's');
}

function update() {
	clear();
}
			</script>
		</div>
		<div id="page-13" class="page">
			<div class="minis horiz">
				<md id="md13-0">
					<h2 id="escala">escala</h2>
					<p>Cambiar <code>sprite.scale</code> escalar√° el colisionador del sprite y la apariencia visual por
						la cantidad especificada.</p>
					<p>Presiona una tecla num√©rica para ver el sprite escalar uniformemente por esa cantidad.</p>
					<p>Presiona "d" para duplicar la escala del sprite.</p>
					<p>Presiona "x" o "y" para escalar el sprite en esa direcci√≥n por una cantidad aleatoria. Pero ten
						en cuenta que si el sprite se escala de manera desigual, la imagen se distorsionar√° y
						permanecer√° as√≠ incluso cuando se escale uniformemente de nuevo.</p>
				</md>
				<md id="md13-1">
					<h2 id="combo-sensors">Combo Sensors</h2>
					<p>Overlap sensors determine if a sprite overlaps with another sprite.</p>
					<p>By default when an overlap checking method is used, and the sprite has no sensors, the
						<code>addDefaultSensors</code> function is used behind the scenes to create sensors for each of
						the sprite's colliders.
					</p>
					<p>You can add additional sensors to a sprite by using the <code>addSensor</code> function.</p>
				</md>
			</div>
			<script type="mie/p5" id="pinball-flipper" horiz="">
let ball, flipper;

function setup() {
	new Canvas(180, 736);
	world.gravity.y = 10;

	ball = new Sprite(100, -20, 30);

	flipper = new Sprite(160, 500, [
		[0, -25],
		[-100, 12.5],
		[0, 25],
		[100, 12.5],
		[0, -25]
	], 'k');

	flipper.addCollider(-60, 0, 25);
	flipper.addCollider(40, 0, 50);
	
	flipper.offset.x = -40;
	flipper.rotation = -20;
	flipper.debug = true;
}

function update() {
	background(16);

	if (mouse.presses()) {
		flipper.rotateTo(20, 8);
	}
	if (mouse.released()) {
		flipper.rotateTo(-20, -8);
	}
	if (frameCount % 100 == 0) {
		ball.life = 200;
		let x = random(50, 140);
		ball = new Sprite(x, -100, 30);
	}
}
			</script>
		</div>
		<div id="page-14" class="page">
			<div class="minis horiz">
				<md id="md14-0">
					<h2 id="colisionadores-combo">Colisionadores Combo</h2>
					<p>Usando la funci√≥n <code>addCollider</code>, puedes agregar varios colisionadores a un sprite.</p>
					<p>¬°Pero solo usa esta funci√≥n cuando realmente sea necesario para el juego! Normalmente, si algo
						requiere muchos colisionadores, como las paredes de un laberinto, simplemente deber√≠as crear
						varios sprites, cada uno con su propio colisionador. Adem√°s, incluso si la imagen de un sprite
						es compleja, t√≠picamente una caja o c√≠rculo ser√° suficiente para las interacciones f√≠sicas,
						especialmente para sprites peque√±os.</p>
					<p>Sin embargo, a veces, realmente necesitar√°s crear un sprite con varios colisionadores. ¬°Por
						ejemplo, si quieres modelar un flipper de pinball!</p>
				</md>
				<md id="md14-1">
					<h2 id="sensores-de-combinaci√≥n">Sensores de Combinaci√≥n</h2>
					<p>Los sensores de superposici√≥n determinan si un sprite se superpone con otro sprite.</p>
					<p>Por defecto, cuando se utiliza un m√©todo de verificaci√≥n de superposici√≥n y el sprite no tiene
						sensores, se utiliza la funci√≥n <code>addDefaultSensors</code> en segundo plano para crear
						sensores para cada uno de los colisionadores del sprite.</p>
					<p>Puedes agregar sensores adicionales a un sprite utilizando la funci√≥n <code>addSensor</code>.</p>
				</md>
			</div>
			<script type="mie/p5" id="stretchy" lines="22">
function setup() {
	new Canvas(500, 200);

	let face = loadImage('/learn/assets/face.webp');
	let stretchy = new Sprite();

	stretchy.update = () => {
		stretchy.moveTowards(mouse, 0.07);
	};
	
	stretchy.draw = () => {
		fill(237, 205, 0);

		push();
		rotate(stretchy.direction);
		ellipse(0, 0, 100 + stretchy.speed, 100 - stretchy.speed);
		pop();

		image(face, stretchy.vel.x * 2, stretchy.vel.y * 2);
	};
}

function update() {
	clear();
}
			</script>
		</div>
		<div id="page-15" class="page">
			<md id="md15-0">
				<h2 id="movimiento-avanzado">Movimiento Avanzado</h2>
				<p>Las funciones de <code>move</code> son imperativas, sobrescriben las velocidades de un sprite. Pero,
					¬øqu√© sucede si deseas que un sprite respete otras fuerzas que act√∫an sobre √©l, como la gravedad?</p>
				<p>Un rumbo es la direcci√≥n que debe seguirse para llegar a un destino. Cambiar el <code>rumbo</code> de
					un sprite no cambiar√° imperativamente su direcci√≥n de movimiento.</p>
				<p>Utiliza <code>applyForce</code> con un par√°metro de entrada, la cantidad de fuerza, para que la
					fuerza se aplique en el √°ngulo del <code>rumbo</code> del sprite.</p>
				<p>En este ejemplo, el dron debe vencer la fuerza de gravedad para volar. ¬°Haz que el dron vuele y luego
					d√©jalo caer, cuando se aplique una fuerza hacia arriba al dron, dejar√° gradualmente de caer y
					comenzar√° a volar!</p>
			</md>
			<script type="mie/p5" id="square-sequence" horiz="" lines="15">
let turtle;

function setup() {
	new Canvas(160, 160);
	turtle = new Turtle(30);

	squareSequence();
}

async function squareSequence() {
	await turtle.move(100);
	await turtle.rotate(90);
  await delay(1000);
	squareSequence();
}

function update() {
	clear();
}
			</script>
			<md id="md15-1">
				<p>La funci√≥n <code>applyForceScaled</code> multiplica la fuerza aplicada al sprite por su masa.</p>
				<p>¬°Puedes usar esta funci√≥n para darles a los sprites su propia gravedad!</p>
				<p>Ambas funciones de fuerza pueden aceptar la fuerza como componentes x e y separados o como una
					cantidad, siempre que establezcas el <code>rumbo</code> del sprite.</p>
				<p>Por defecto, la fuerza se aplica al centro de masa del sprite. Pero las funciones
					<code>applyForce</code> y <code>applyForceScaled</code> tambi√©n pueden aceptar un √∫ltimo par√°metro
					de entrada, un objeto de posici√≥n con propiedades x e y que especifica la posici√≥n relativa donde se
					aplicar√° la fuerza en el sprite.</p>
			</md>
			<script type="mie/p5" id="random-sequence" horiz="" lines="17">
let turtle, ball;

function setup() {
	new Canvas(160, 304);
	turtle = new Turtle(30);
	ball = new Sprite(80, 152, 50);

	randomSequence();
}

async function randomSequence() {
	let x = random(0, width);
	let y = random(0, height);
	await turtle.rotateTo(x, y, 5);
	await turtle.moveTo(x, y, 3);
	randomSequence();
}

function update() {
	clear();
}
			</script>
			<md id="md15-2">
				<p>Utiliza la funci√≥n <code>attractTo</code> para atraer al sprite hacia una posici√≥n aplicando fuerza.
					La posici√≥n puede ser proporcionada como un objeto con propiedades x e y, o como par√°metros
					separados x e y.</p>
				<p>Este ejemplo simula la √≥rbita de un electr√≥n alrededor del n√∫cleo de un √°tomo.</p>
				<p>Ten en cuenta que las funciones de movimiento avanzado mostradas en esta p√°gina no despertar√°n a los
					<a href="./world.html" target="_blank">sprites en reposo</a>!</p>
			</md>
			<script type="mie/p5" base-8="" hidden="">
let player, ally;

function setup() {
	new Canvas(500, 100);
	player = new Sprite(400, 50, 20);
	ally = new Sprite(200, 50, 20, 20, 'n');
}

function update() {
	clear();
}
			</script>
			<script type="mie/p5" id="angleTo" base="8">
player.moveTowards(mouse);

let distance = dist(player.x, player.y, ally.x, ally.y);

if (distance > 40) {
	ally.direction = ally.angleTo(player);
	ally.speed = 2;
} else if (distance < 30) {
	ally.speed = 0;
}
			</script>
		</div>

		<div class="break"></div>
		<div id="toc">
			<a id="prevPage" class="navLink">P√°gina anterior</a>
			<div id="pageNav" class="submenu">
				<a data-page="0" href="sprite.html?page=0">Propiedades B√°sicas</a>
				<a data-page="1" href="sprite.html?page=1">F√≠sica</a>
				<a data-page="2" href="sprite.html?page=2">Movimiento</a>
				<a data-page="3" href="sprite.html?page=3">Sprites con Im√°genes</a>
				<a data-page="4" href="sprite.html?page=4">Constructor de Sprite</a>
				<a data-page="5" href="sprite.html?page=5">Colisiones</a>
				<a data-page="6" href="sprite.html?page=6">Superposiciones</a>
				<a data-page="7" href="sprite.html?page=7">Rotaci√≥n</a>
				<a data-page="8" href="sprite.html?page=8">Escalado</a>
				<a data-page="9" href="sprite.html?page=9">Atributos F√≠sicos</a>
				<a data-page="10" href="sprite.html?page=10">Movimiento Avanzada</a>
				<a data-page="11" href="sprite.html?page=11">Cadenas</a>
				<a data-page="12" href="sprite.html?page=12">Pol√≠gonos</a>
				<a data-page="13" href="sprite.html?page=13">Combos de Colisionadores</a>
				<a data-page="14" href="sprite.html?page=14">Dibujo Personalizado</a>
				<a data-page="15" href="sprite.html?page=15">Secuenciaci√≥n de Movimiento</a>
			</div>
			<a id="nextPage" class="navLink">Siguiente p√°gina</a>
		</div>
		<div class="break"></div>
		<footer id="credits" class="text-small">Creado por Quinton Ashley (@quinton-ashley) derechos de autor 2022-2024
		</footer>
	</article>

	<!-- <script src="https://cdn.jsdelivr.net/npm/p5@1/lib/p5.min.js"></script> -->
<script src="/v3/q5.min.js"></script>
<script src="/v3/planck.min.js"></script>
<script src="/v3/p5play.min.js"></script>
<script>
window.mie = { autoLoad: false };

	</script>
	<script src="/learn/mie.js"></script>
<script src="/learn/learn.js"></script>
<script src="/account/account.js"></script>
</body>

</html>
