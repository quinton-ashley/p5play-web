<!DOCTYPE html><html lang="es"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>p5play : Sprite</title>
    <link rel="icon" href="/assets/p5play_logo.svg">
    <link rel="stylesheet" href="/learn/style.css">
  </head>

  <body class="dark">
    <article>
      <nav id="topNav">
        <a href="index.html" id="logoLink" class="active">
          <img alt="p5play logo" src="/assets/p5play_logo.svg" class="logo">
          <span>p5play</span>
        </a>
        <hr>
        <a href="sprite.html" class="active">Sprite</a>
        <a href="group.html">Group</a>
        <a href="sprite_animation.html">Ani</a>
        <a href="input_devices.html">Input</a>
        <a href="camera.html">Camera</a>
        <a href="joints.html">Joints</a>
        <a href="canvas.html">...</a>
        <hr>
        <a id="darkMode" onclick="toggleDarkMode()" tabindex="0" role="button" title="dark mode toggle">
          <div id="darkModeIcon"></div>
        </a>
      </nav>

      <div class="break"></div>

      <div id="page-0" class="page">
        <md id="md0-0"><h2 id="configuraci√≥n">Configuraci√≥n</h2>
          <p>
            El c√≥digo dentro de la funci√≥n <code>setup</code> de p5.js (o q5.js)
            se ejecuta cuando comienza el programa. El constructor
            <code>new Canvas()</code> crea una secci√≥n de la pantalla en la que
            el programa puede dibujar.
          </p>
          <p>
            La funci√≥n <code>draw</code> de p5.js se ejecuta 60 veces por
            segundo por defecto. La funci√≥n <code>background</code> se puede
            usar para llenar el canvas con un color cada vez que se dibuja.
          </p>
          <p>
            ¬°Intenta cambiar el ancho y la altura del canvas (los n√∫meros dentro
            del constructor <code>Canvas</code>), luego reinicia el programa de
            ejemplo!
          </p>
        </md>
        <script type="mie/p5" id="setup-and-draw">
function setup() {
	new Canvas(250, 100);
}

function draw() {
	background('blue');
}
			</script>
        <div class="break"></div>
        <md id="md0-1"><h2 id="¬øqu√©-es-un-sprite">¬øQu√© es un sprite?</h2>
          <p>¬°Un sprite es un fantasma!</p>
          <p>
            Los desarrolladores de videojuegos usan la palabra "sprite" para
            referirse a personajes, objetos, o cualquier otra cosa que se mueva
            sobre un fondo.
          </p>
          <p>
            El constructor new Sprite() crea un objeto sprite, el cual contiene
            variables que definen la posici√≥n, tama√±o y apariencia de un sprite.
          </p>
          <p>
            ¬°Intenta editar las propiedades de los sprites de caja y c√≠rculo en
            los mini ejemplos a continuaci√≥n!
          </p>
        </md>
        <div class="minis horiz">
          <script type="mie/p5" id="box" base-0="" horiz="" lines="9">
let sprite;

function setup() {
	new Canvas(238, 100);

	sprite = new Sprite();
	sprite.width = 50;
	sprite.height = 50;
}

function draw() {
	clear();
}
				</script>
          <script type="mie/p5" id="circle" base-1="" horiz="" lines="8">
let sprite;

function setup() {
	new Canvas(238, 100);

	sprite = new Sprite();
	sprite.diameter = 50;
}

function draw() {
	clear();
}
				</script>
        </div>
        <div class="minis">
          <script type="mie/p5" id="x">
sprite.x = 150;
				</script>
          <script type="mie/p5" id="y" base="1">
sprite.y = 30;
				</script>
          <script type="mie/p5" id="position">
sprite.pos = {x: 50, y: 0};
				</script>
          <script type="mie/p5" id="rotation">
sprite.rotation = 45;
				</script>
          <script type="mie/p5" id="color" base="1">
sprite.color = 'pink';
sprite.stroke = 'red';
				</script>
          <script type="mie/p5" id="textColor">
sprite.textColor = 'blue';
sprite.text = "Hello!";
				</script>
        </div>

        <div class="minis">
          <script type="mie/p5" id="width">
sprite.w = 200;
				</script>
          <script type="mie/p5" id="height">
sprite.h = 80;
				</script>
          <script type="mie/p5" id="diameter" base="1">
sprite.d = 40;
				</script>
          <script type="mie/p5" id="radius">
sprite.r = 40;
				</script>
          <script type="mie/p5" id="textSize">
sprite.textSize = 40;
sprite.text = "p5";
				</script>
          <script type="mie/p5" id="visible">
sprite.visible = false;
				</script>
        </div>
        <div class="break"></div>
        <div class="minis horiz">
          <md id="md0-2"><h2 id="¬°pru√©balo">¬°Pru√©balo!</h2>
            <p>
              Intenta convertir el sprite llamado <code>ball</code> en un
              c√≠rculo azul con un di√°metro de 30 y col√≥calo en la esquina
              superior derecha del canvas.
            </p>
          </md>
          <script type="mie/p5" id="Level-0-Challenge-Solution" hide-editor="">
let ball;

function setup() {
	new Canvas(500, 60);
	ball = new Sprite();
	ball.diameter = 30;
	ball.color = 'blue';
	ball.x = 480;
	ball.y = 16;
}

function draw() {
	clear();
}
				</script>
        </div>
        <script type="mie/p5" id="Level-0-Challenge" lines="13" horiz="">
let ball;

function setup() {
	new Canvas(200, 256);
	ball = new Sprite();
	// write your code here!
  
}

function draw() {
	clear();
}
			</script>
      </div>
      <div id="page-1" class="page">
        <md id="md1-0"><h2 id="f√≠sica-de-los-sprites">F√≠sica de los sprites</h2>
          <p>
            El colisionador de un sprite se utiliza para detectar colisiones con
            otros sprites. Por defecto, los sprites tienen un colisionador de
            f√≠sica <code>'dynamic'</code> que permite que el sprite se mueva
            libremente y sea afectado por la gravedad.
          </p>
          <p>
            Los colisionadores <code>'static'</code> no pueden moverse. Los
            colisionadores <code>'kinematic'</code> pueden moverse
            program√°ticamente pero no por otros sprites. Adem√°s, no colisionar√°n
            con otros colisionadores kinem√°ticos. Establecer el tipo de
            colisionador de un sprite a <code>'none'</code> lo elimina de la
            simulaci√≥n f√≠sica.
          </p>
          <p>
            El tipo de colisionador tambi√©n puede establecerse usando la primera
            letra del nombre del tipo de colisionador: <code>'d'</code>,
            <code>'s'</code>, <code>'k'</code>, o <code>'n'</code>.
          </p>
          <p>
            ¬°Haz clic en el icono de recargar en la esquina superior derecha de
            un mini ejemplo para volver a reproducirlo!
          </p>
        </md>
        <script type="mie/p5" id="dynamic-and-static-colliders" base-2="" horiz="" lines="16">
let ball, floor;

function setup() {
	new Canvas(238, 200);
	world.gravity.y = 10;

	ball = new Sprite();
	ball.diameter = 50;
	ball.y = 30;

	floor = new Sprite();
	floor.y = 190;
	floor.w = 238;
	floor.h = 5;
	floor.collider = 'static';
}

function draw() {
	clear();
}
			</script>
        <div class="minis">
          <script type="mie/p5" id="anti-gravity" base="2">
world.gravity.y = -1;
				</script>
          <script type="mie/p5" id="sloped-floor" base="2">
floor.rotation = 2;
				</script>
        </div>

        <div class="minis">
          <script type="mie/p5" id="rising-platform" base="2">
floor.collider = 'k';
floor.velocity.y = -1;
				</script>
          <script type="mie/p5" id="whoops!" base="2">
floor.collider = 'none';
				</script>
        </div>
        <div class="break"></div>
        <div class="minis horiz">
          <md id="md1-1"><h2 id="¬°pru√©balo">¬°Pru√©balo!</h2>
            <p>
              Intenta crear un sprite llamado <code>peg</code> con un
              colisionador est√°tico y forma de c√≠rculo. Crea un sprite
              <code>block</code> con un colisionador din√°mico y forma de caja.
              Posiciona el bloque de modo que golpee el clavo y caiga hacia la
              derecha.
            </p>
            <p>
              Cada vez que la funci√≥n <code>draw</code> de p5.js termina, los
              sprites se dibujan y actualizan autom√°ticamente. Nota que
              <code>world</code> se crea cuando se carga p5play pero por defecto
              no hay gravedad. Intenta establecer
              <code>world.gravity.y</code> en un n√∫mero positivo.
            </p>
            <p>
              Para un desaf√≠o adicional, intenta restablecer la posici√≥n
              original del bloque despu√©s de que caiga.
            </p>
          </md>
          <script type="mie/p5" id="Level-1-Challenge-Solution" hide-editor="">
let peg, block;

function setup() {
	new Canvas(460, 60);
	world.gravity.y = 10;

	peg = new Sprite();
	peg.diameter = 10;
	peg.y = 40;
	peg.collider = 'static';

	block = new Sprite();
	block.w = 30;
	block.h = 30;
	block.x = 236;
	block.y = 0;
}

function draw() {
	clear();
}
				</script>
        </div>
        <script type="mie/p5" id="Level-1-Challenge" lines="13" horiz="">
let peg, block;

function setup() {
	new Canvas(200, 364);

}

function draw() {
	clear();
}
			</script>
      </div>
      <div id="page-2" class="page">
        <script type="mie/p5" id="idle-player" lines="11" hide="" base-3="">
let player, block;

function setup() {
	new Canvas(500, 100);

	player = new Sprite();
	player.diameter = 50;
	player.x = 400;

	block = new Sprite();
}

function draw() {
	clear();
}
			</script>
        <md id="md2-0"><h2 id="movimiento-de-los-sprites">Movimiento de los sprites</h2>
          <p>¬°Cambiar la posici√≥n de un sprite lo teletransporta!</p>
          <p>Intenta hacer clic alrededor de este mini-ejemplo.</p>
        </md>
        <script type="mie/p5" id="teleport" base="3">
if (mouse.presses()) {
	player.x = mouse.x;
	player.y = mouse.y;
}
			</script>
        <md id="md2-1"><p>
            El siguiente ejemplo muestra qu√© sucede si un sprite se
            teletransporta cada vez que la funci√≥n de dibujo de p5.js renderiza
            un frame.
          </p>
          <p>
            Si quieres que un sprite interact√∫e f√≠sicamente con otros sprites
            mientras se mueve, ¬°no lo teletransportes!
          </p>
        </md>
        <script type="mie/p5" id="teleport-:-continuously-üëé" base="3">
player.x = mouse.x;
player.y = mouse.y;
			</script>
        <md id="md2-2"><p>
            Todos los otros m√©todos de movimiento en esta p√°gina funcionan
            cambiando las velocidades de los ejes x e y del sprite.
            <code>velocity</code> tambi√©n conocida como <code>vel</code> es un
            Vector de p5.js, puedes usar cualquier funci√≥n de Vector en √©l.
          </p>
          <p>
            Puede que tengas que reiniciar este ejemplo para ver moverse al
            sprite.
          </p>
        </md>
        <script type="mie/p5" id="velocity-:-continuously" base="3">
player.vel.x = -2;
player.vel.y = 0.1;
			</script>
        <md id="md2-3"><p>
            Mueve el sprite indefinidamente estableciendo su
            <code>direction</code> y <code>speed</code>.
          </p>
          <p>
            Tambi√©n puedes establecer la direcci√≥n de un sprite usando un nombre
            de direcci√≥n como: 'up', 'down', 'left', 'right', 'upLeft',
            'upRight', 'downLeft', 'downRight'.
          </p>
          <p>
            Nota que p5play convierte estos nombres de direcci√≥n a sus
            correspondientes valores de √°ngulo.
          </p>
        </md>
        <script type="mie/p5" id="direction-+-speed-:-continuously" base="3">
player.direction = 187;
player.speed = 3;
			</script>
        <md id="md2-4"><p>
            La funci√≥n <code>move</code> mueve un sprite a trav√©s de una
            distancia fija. La direcci√≥n y la velocidad del movimiento pueden
            especificarse como par√°metros de la funci√≥n o establecerse por
            separado.
          </p>
        </md>
        <script type="mie/p5" id="move-:-impulse" base="3">
if (kb.presses('left')) {
	//   (distance, direction, speed)
	player.move(30, 'left', 3);
}
			</script>
        <md id="md2-5"><p>
            La funci√≥n <code>moveTowards</code> mueve un sprite hacia una
            posici√≥n, a un porcentaje de la distancia a esa posici√≥n.
          </p>
          <p>
            En este ejemplo, el jugador se mueve el 10% de la distancia al rat√≥n
            en cada llamada de dibujo de p5.js. Su velocidad, y la fuerza que
            ejerce sobre el bloque, es proporcional a la distancia que se mueve.
          </p>
        </md>
        <script type="mie/p5" id="moveTowards-:-continuously" base="3">
//             (position, tracking)
player.moveTowards(mouse, 0.10);
			</script>
        <md id="md2-6"><p>
            La funci√≥n <code>moveTo</code> genera un impulso que mueve un sprite
            a una posici√≥n a una velocidad constante.
          </p>
          <p>
            Pero ten en cuenta que si el sprite es actuado por una fuerza como
            la gravedad o choca con otro sprite, su velocidad y direcci√≥n se
            ver√°n afectadas y puede que no llegue a la posici√≥n objetivo.
          </p>
          <p>
            Cualquier funci√≥n de movimiento que acepte un objeto con propiedades
            x e y podr√≠a en su lugar ser llamada con n√∫meros de posici√≥n (x, y).
          </p>
        </md>
        <script type="mie/p5" id="moveTo-:-impulse" base="3">
if (mouse.presses()) {
	//        (position, speed)
	player.moveTo(mouse, 8);
}
			</script>
        <md id="md2-7"><p>
            Esperamos que los ejemplos en esta p√°gina te ayuden a entender
            algunas de las opciones de movimiento disponibles en p5play.
          </p>
          <p>
            Ten en cuenta que las funciones move, moveTo y moveTowards anulan el
            movimiento actual de un sprite, oblig√°ndolo a moverse en una nueva
            direcci√≥n. ¬°Eso podr√≠a no ser siempre lo que quieres!
          </p>
          <p>
            Para aprender m√°s sobre el movimiento de sprites, lee las p√°ginas de
            "Secuenciaci√≥n de Movimientos" y "Movimiento Avanzado".
          </p>
        </md>
        <script type="mie/p5" id="segmented-motion" base="3">
if (kb.pressing('left')) player.vel.x = -5;
else if (kb.pressing('right')) player.vel.x = 5;
else player.vel.x = 0;
			</script>
      </div>
      <div id="page-3" class="page">
        <md id="md3-0"><h2 id="imagen-de-sprite">Imagen de sprite</h2>
          <p>
            <code>sprite.image</code> o <code>sprite.img</code> puede
            establecerse en una p5.Image o una ruta de url a un archivo de
            imagen.
          </p>
          <p>
            Si necesitas que una imagen se cargue antes de que comience tu
            programa, es mejor usar
            <a href="https://p5js.org/reference/#/p5/loadImage"><code>loadImage</code></a>
            dentro de la funci√≥n <code>preload</code> de p5.js.
          </p>
          <p>
            <code>sprite.scale</code> cambia el tama√±o tanto del colisionador
            del sprite como de su apariencia visual. Un valor de escala de 2
            duplica el tama√±o del sprite.
          </p>
          <p>
            Intenta presionar el bot√≥n izquierdo del rat√≥n. Cuando la propiedad
            <code>sprite.debug</code> est√° establecida en true puedes ver el
            colisionador del cuerpo f√≠sico del sprite. ¬°Puedes hacer que el
            tama√±o del colisionador sea diferente del tama√±o de la imagen!
          </p>
        </md>
        <script type="mie/p5" id="image">
let monster;

function setup() {
	new Canvas(500, 120);

	monster = new Sprite();
	monster.img = '/learn/assets/monster.png';
	monster.diameter = 70;
}

function draw() {
	clear();
	if (kb.presses(2)) {
		monster.scale = 2;
	}
	monster.debug = mouse.pressing();
}
			</script>
        <div class="break"></div>
        <div class="minis">
          <md id="md3-1"><h2 id="arte-de-p√≠xeles">Arte de P√≠xeles</h2>
            <p>
              Puedes utilizar la funci√≥n <code>spriteArt</code> para crear
              im√°genes de arte de p√≠xeles para tus sprites. Recibe una cadena
              como entrada y devuelve una imagen. Cada car√°cter en la cadena
              representa el valor de color de un p√≠xel en la imagen.
            </p>
            <p>
              El segundo par√°metro de entrada de la funci√≥n
              <code>spriteArt</code> es la escala de la imagen.
            </p>
          </md>
          <md id="md3-2"><h2 id="¬°pru√©balo">¬°Pru√©balo!</h2>
            <p>
              ¬°Intenta crear tu propio arte de p√≠xeles! Echa un vistazo al
              alfabeto a continuaci√≥n para ver qu√© color representa cada letra
              de forma predeterminada.
            </p>
          </md>
        </div>
        <script type="mie/p5" id="smiley" lines="15">
let smiley;

function setup() {
	new Canvas(500, 120);
	let smileText = `
..yyyyyy
.yybyybyy
yyyyyyyyyy
yybyyyybyy
.yybbbbyy
..yyyyyy`;

	smiley = new Sprite();
	smiley.img = spriteArt(smileText, 16);
}

function draw() {
  noLoop();
}
			</script>
        <div style="width: 100%; padding: 0">
          <script type="mie/p5" id="default-colors" hide-editor="">
function setup() {
	new Canvas(1030, 70);
	let alphaText = `
....b.........d......ff.....h....i...j..k....l...............................t.....................
.aa.bbb.ccc.ddd.ee...f..ggg.hhh.........k.k..l..mmm.nnn.ooo.ppp.qqq.rrr..ss.ttt.u.u.v.v.x.x.y.y.zz
a.a.b.b.c...d.d.ee..fff.ggg.h.h..i...j..kk...l..mmm.n.n.o.o.p.p.q.q.r....s...t..u.u.v.v..x..yyy..z.
.aa.bbb.ccc.ddd.eee..f....g.h.h..i...j..k.k..ll.m.m.n.n.ooo.ppp.qqq.r...ss...tt.uuu..v..x.x...y..zz
........................ggg.........jj......................p.....q.........................yy.....
`;

	let alpha = new Sprite();
	alpha.img = spriteArt(alphaText, 10);

	background(20);
	noLoop();
}

function draw() {}

        </script>
        </div>
        <div class="break"></div>
        <md id="md3-3"><h2 id="colores-personalizados">Colores Personalizados</h2>
          <p>
            Tambi√©n puedes crear arte de p√≠xeles que utilice colores
            personalizados creando una paleta de colores y pas√°ndola como tercer
            par√°metro a la funci√≥n <code>spriteArt</code>.
          </p>
          <p>
            Las paletas de colores en p5play deben proporcionarse en formato
            <a href="https://p5js.org/reference/#/p5/object">Objeto JavaScript</a>. Un objeto JS simple es como un diccionario. Puedes definir un
            color para cada letra que uses en tu arte de p√≠xeles. Para crear un
            color, utiliza la funci√≥n
            <a href="https://p5js.org/reference/#/p5/color"><code>color</code></a>
            de p5.js, que acepta valores RGB (rojo, verde, azul) o c√≥digos de
            color HEX.
          </p>
          <p>
            La forma m√°s sencilla de encontrar colores es utilizar un
            <a href="https://www.google.com/search?q=selector+de+colores+google">selector de colores</a>.
          </p>
        </md>
        <script type="mie/p5" id="blue-smiley" lines="20">
let smiley;

function setup() {
	new Canvas(500, 120);
	let smileText = `
..uuuuuu
.uubuubuu
uuuuuuuuuu
uubuuuubuu
.uubbbbuu
..uuuuuu`;

	let palette = {
		u: color(60, 220, 255),
		b: color('#303060')
	};

	smiley = new Sprite();
	smiley.img = spriteArt(smileText, 16, palette);
}

function draw() {
	noLoop();
}
			</script>
      </div>
      <div id="page-4" class="page">
        <div class="minis horiz">
          <md id="md4-0"><h2 id="crea-sprites-m√°s-r√°pido">Crea Sprites m√°s r√°pido</h2>
            <p>
              Dentro del constructor de Sprite, <code>new Sprite()</code>,
              puedes especificar la posici√≥n, el tama√±o y el tipo de
              colisionador del sprite.
            </p>
            <p>
              Como viste en las p√°ginas de referencia de Sprite anteriores, no
              necesitas agregar ninguna entrada al constructor de Sprite para
              crear un sprite. Pero si quieres establecer el tama√±o de un sprite
              en el constructor, necesitar√°s especificar su posici√≥n primero.
            </p>
            <p>
              Por defecto, si no se dan entradas al constructor de Sprite, los
              nuevos sprites se posicionan en el centro del lienzo, con un ancho
              y altura de 50 p√≠xeles, y un colisionador din√°mico.
            </p>
          </md>
          <script type="mie/p5" id="default-sprite" lines="5" horiz="">
function setup() {
	new Canvas(100, 100);

	new Sprite();
}

function draw() {}
				</script>
        </div>
        <div class="minis horiz">
          <script type="mie/p5" id="Ooo!" horiz="" lines="18">
let box, circle;

function setup() {
	new Canvas(50, 200);
	world.gravity.y = 10;

	//             	( x,  y,  w,  h, collider)
	box = new Sprite(25, 70, 10, 90, 'static');
	// same as setting the values separately
	// box.x = 25;
	// box.y = 70;
	// box.width = 10;
	// box.height = 90;
	// box.collider = 'static';

	// 					 	     ( x,   y,  d, collider)
	circle = new Sprite(25, 140, 10, 'static');
}

function draw() {
	clear();
}
				</script>
          <script type="mie/p5" id="ball-on-the-floor" lines="10" horiz="">
let ball, floor;

function setup() {
	new Canvas(80, 160);
	world.gravity.y = 10;
	
	ball = new Sprite(40, 30, 50);

	floor = new Sprite(40, 155, 80, 5, 'static');
}

function draw() {
	clear();
}
				</script>
        </div>
        <div class="break"></div>
        <md id="md4-1"><h2 id="¬°pru√©balo">¬°Pru√©balo!</h2>
          <p>Intenta crear dos sprites usando el constructor de sprite.</p>
        </md>
        <script type="mie/p5" id="Level-4-Challenge" lines="13" horiz="">
let sprite1, sprite2;

function setup() {
	new Canvas(50, 256);

}

function draw() {
	clear();
}
			</script>
      </div>
      <div id="page-5" class="page">
        <md id="md5-0"><h2 id="colisiones">Colisiones</h2>
          <p>
            En el primer fotograma en que un sprite colisiona con otro sprite,
            la funci√≥n <code>collides</code> devuelve true.
          </p>
          <p>
            Mientras un sprite est√° colisionando con otro sprite, la funci√≥n
            <code>colliding</code> devuelve el n√∫mero de fotogramas que ha
            ocurrido la colisi√≥n.
          </p>
          <p>
            En el primer fotograma despu√©s de que dos sprites colisionaron, la
            funci√≥n <code>collided</code> devuelve true.
          </p>
        </md>
        <script type="mie/p5" id="pillar-stomp!" horiz="">
let player, pillar;

function setup() {
	new Canvas(60, 342);
	world.gravity.y = 10;
	
	pillar = new Sprite(30, 362, 30, 500, 'static');
	player = new Sprite(30, 0, 50);
}

function draw() {
	clear();

	if (player.collides(pillar)) {
		player.vel.y = -5;
		pillar.h -= 52;
	}
}
			</script>
        <script type="mie/p5" id="drop-block" horiz="">
let block, floor;

function setup() {
	new Canvas(60, 342);
	world.gravity.y = 10;
	
	block = new Sprite(30, 30);
	floor = new Sprite(30, 300, 60, 5, 'static');
	floor.color = 'red';
}

function draw() {
	clear();
	if (block.colliding(floor)) {
		block.color = 'red';
	} else block.color = 'blue';

	if (block.colliding(floor) > 60) {
		block.vel.y = -9;
	}
}
			</script>
        <script type="mie/p5" id="break-floor" horiz="">
let block, floor;

function setup() {
	new Canvas(60, 342);
	world.gravity.y = 10;
	
	block = new Sprite(30, 30);
	floor = new Sprite(30, 300, 60, 5, 'static');
}

function draw() {
	clear();
	if (block.collided(floor)) {
		floor.collider = 'dynamic';
	}
}
			</script>
      </div>
      <div id="page-6" class="page">
        <md id="md6-0"><h2 id="superposiciones">Superposiciones</h2>
          <p>
            ¬°Los sprites colisionan por defecto, pero tambi√©n pueden
            superponerse!
          </p>
        </md>
        <script type="mie/p5" id="overlap" horiz="" lines="8" base-4="">
function setup() {
	new Canvas(200, 128);

	sprite1 = new Sprite(90, 50);
	sprite2 = new Sprite(115, 75);

	sprite1.overlaps(sprite2);
}

function draw() {
	clear();
}
			</script>
        <md id="md6-1"><h2 id="capa">Capa</h2>
          <p>
            Por defecto, los sprites se dibujan en el orden en que fueron
            creados. Puedes cambiar el orden de dibujo editando la propiedad
            <code>.layer</code> del sprite. Los sprites con el valor de capa m√°s
            alto se dibujan primero.
          </p>
        </md>
        <script type="mie/p5" id="layer" horiz="" lines="8" base="4">
sprite1.layer = 2;
sprite2.layer = 1;
			</script>
        <md id="md6-2"><p>
            En el primer fotograma en que un sprite se superpone con otro
            sprite, la funci√≥n <code>overlaps</code> devuelve true.
          </p>
          <p>
            Mientras un sprite se superpone con otro sprite, la funci√≥n
            <code>overlapping</code> devuelve el n√∫mero de fotogramas que ha
            ocurrido la superposici√≥n.
          </p>
          <p>
            En el primer fotograma despu√©s de que dos sprites se superpongan, la
            funci√≥n <code>overlapped</code> devuelve true.
          </p>
          <p>
            Ten en cuenta que las interacciones f√≠sicas entre sprites,
            incluyendo colisiones y superposiciones, no pueden detectarse
            correctamente cuando un sprite es teletransportado, ¬°su posici√≥n
            cambia directamente!
          </p>
        </md>
        <script type="mie/p5" id="collect-coin">
let player, coin;

function setup() {
	new Canvas(500, 100);

	coin = new Sprite(400, 50, 30);
	coin.color = 'yellow';
	player = new Sprite(50, 50);
}

function draw() {
	clear();
	player.moveTowards(mouse);
		
	if (player.overlaps(coin)) coin.remove();
}
			</script>
        <div class="break"></div>
        <md id="md6-3"><h2 id="¬°pru√©balo">¬°Pru√©balo!</h2>
          <p>
            Intenta hacer que el sprite azul cambie a rojo solo si se superpone
            con el sprite rojo.
          </p>
          <p>
            Tenga en cuenta que este ejemplo utiliza tonos personalizados de
            azul y rojo mediante la utilizaci√≥n de la funci√≥n
            <a href="https://p5js.org/reference/#/p5/color">color de p5.js</a>
          </p>
        </md>
        <script type="mie/p5" id="Level-6-Challenge" lines="20" horiz="">
let sprite1, sprite2;

function setup() {
	new Canvas(100, 400);

	sprite1 = new Sprite(50, 50);
	sprite1.color = color(40, 140, 255);

	sprite2 = new Sprite(50, 300);
	sprite2.color = color(255, 30, 10);
}

function draw() {
	clear();
	sprite1.moveTowards(mouse);

	
	
}
			</script>
        <div class="break"></div>
        <md id="md6-4"><h2 id="cambiar-entre-superposiciones-y-colisiones">
            Cambiar entre superposiciones y colisiones
          </h2>
          <p>
            Por defecto, si compruebas si hay una superposici√≥n entre dos
            sprites, ya no colisionar√°n. Puedes anular esto comprobando si hay
            una colisi√≥n entre los sprites.
          </p>
          <p>
            En este ejemplo, al presionar la tecla de espacio se permite
            temporalmente al jugador atravesar la pared como un fantasma.
          </p>
        </md>
        <script type="mie/p5" id="ghost-ability">
let player, wall;

function setup() {
	new Canvas(500, 100);

	wall = new Sprite(250, 50, 30, 400, 's');
	wall.color = 'purple';
	player = new Sprite(50, 50);
}

function draw() {
	clear();
	player.moveTowards(mouse);

	if (kb.pressing('space')) {
		player.overlaps(wall);
		player.color = 'purple';
	} else {
		player.collides(wall);
		player.color = 'orange';
	}
}

			</script>
      </div>
      <div id="page-7" class="page">
        <script type="mie/p5" base-5="" hide="">
let sprite;

function setup() {
	new Canvas(60, 80);

	sprite = new Sprite();
	sprite.h = 20;
}

function draw() {
	clear();
}
			</script>
        <script type="mie/p5" base-8="" hide="">
let sprite;

function setup() {
	new Canvas(500, 80);

	sprite = new Sprite();
	sprite.h = 20;
}

function draw() {
	clear();
}
			</script>
        <md id="md7-0"><h2 id="rotaci√≥n-de-sprite">Rotaci√≥n de Sprite</h2>
          <p>
            Cambiar directamente la propiedad <code>rotation</code> de un sprite
            lo teletransportar√° al √°ngulo de rotaci√≥n especificado.
          </p>
          <p>
            ¬°No teletransportes un sprite si quieres que interact√∫e f√≠sicamente
            con otros sprites mientras est√° rotando!
          </p>
        </md>
        <script type="mie/p5" id="rotation-(teleport)" base="5">
if (kb.pressing('space')) sprite.rotation = 90;
else sprite.rotation = 0;
			</script>
        <md id="md7-1"><p>
            Todos los otros m√©todos de rotaci√≥n en esta p√°gina funcionan
            cambiando la <code>rotationSpeed</code> del sprite.
          </p>
        </md>
        <script type="mie/p5" id="rotationSpeed" base="5">
sprite.rotationSpeed = 1;
			</script>
        <md id="md7-2"><p>
            Usa la funci√≥n <code>rotate</code> para rotar un sprite una
            cantidad.
          </p>
          <p>
            El segundo par√°metro opcional es la velocidad a la que rota el
            sprite por fotograma.
          </p>
        </md>
        <script type="mie/p5" id="rotate" base="5">
//                                 (angle, rotationSpeed)
if (kb.presses('space')) sprite.rotate(15, 3);
			</script>
        <md id="md7-3"><p>
            Usa la funci√≥n <code>rotateTo</code> para rotar un sprite a un
            √°ngulo. La velocidad de rotaci√≥n se puede dar como un segundo
            par√°metro opcional.
          </p>
          <p>
            Alternativamente, si a la funci√≥n se le da un objeto con coordenadas
            x, y, el sprite girar√° para enfrentar esa posici√≥n. El √°ngulo "de
            frente" es el √°ngulo en el que deber√≠a estar el sprite cuando est√°
            enfrentando la posici√≥n objetivo. Intenta cambiarlo de 0 a 90.
            Cuando hagas clic, el lado largo del sprite girar√° para enfrentar el
            rat√≥n.
          </p>
        </md>
        <div class="minis horiz">
          <script type="mie/p5" id="rotateTo-(an-angle)" base="5">
//          (angle, rotationSpeed)
if (kb.presses('left')) sprite.rotateTo(-90, 5);
if (kb.presses('right')) sprite.rotateTo(0, 5);
				</script>
          <script type="mie/p5" id="rotateTo-(face-a-position)" base="8">
//                                (pos, speed, facing)
if (mouse.presses()) sprite.rotateTo(mouse, 5, 0);
				</script>
        </div>
        <md id="md7-4"><p>
            Usa la funci√≥n <code>rotateTowards</code> para girar un sprite hacia
            un √°ngulo o hacia una posici√≥n.
          </p>
          <p>
            El segundo par√°metro opcional es la velocidad de seguimiento, un
            porcentaje de la distancia que el sprite se mueve en cada fotograma
            al √°ngulo de rotaci√≥n objetivo, 0.1 (10%) por defecto.
          </p>
        </md>
        <script type="mie/p5" id="rotateTowards" base="5">
//           (position, tracking, facing)
sprite.rotateTowards(mouse, 0.1, 0);
			</script>
        <md id="md7-5"><p>
            Usa la propiedad <code>offset</code> para mover el cuerpo f√≠sico del
            sprite en relaci√≥n con su centro.
          </p>
          <p>
            Cuando <code>sprite.debug</code> es true, el centro del sprite est√°
            marcado con una peque√±a cruz verde. El punto central es donde se
            encuentran las coordenadas x e y del sprite. Tambi√©n es el centro de
            rotaci√≥n.
          </p>
        </md>
        <script type="mie/p5" id="offset">
function setup() {
	new Canvas(500, 200);

	let flipper = new Sprite(250, 100, 200, 20, 'k');
	flipper.debug = true;
	flipper.rotationSpeed = 1;
	flipper.offset.x = 40;
}

function draw() {
	clear();
	if (mouse.presses()) new Sprite(mouse.x, mouse.y, 10);
}

			</script>
      </div>
      <div id="page-8" class="page">
        <md id="md8-0"><h2 id="secuenciaci√≥n-de-movimientos">
            Secuenciaci√≥n de movimientos
          </h2>
          <p>
            Estos ejemplos utilizan un sprite <code>Turtle</code> que es
            simplemente un sprite regular que es verde y tiene forma de
            tri√°ngulo para ese aspecto cl√°sico de la programaci√≥n de tortugas.
          </p>
          <p>
            Puedes usar la palabra clave <code>await</code> dentro de una
            funci√≥n <code>async</code> para esperar a que un movimiento termine
            antes de continuar con el siguiente movimiento. Esto es √∫til para
            hacer que un sprite se mueva en secuencia.
          </p>
        </md>
        <script type="mie/p5" id="square-sequence" horiz="" lines="15">
let turtle;

function setup() {
	new Canvas(160, 160);
	turtle = new Turtle(30);

	squareSequence();
}

async function squareSequence() {
	await turtle.move(100);
	await turtle.rotate(90);
  await delay(1000);
	squareSequence();
}

function draw() {
	clear();
}
			</script>
        <md id="md8-1"><p>
            Las funciones <code>move</code>, <code>moveTo</code>,
            <code>rotate</code>, y <code>rotateTo</code> todas devuelven una
            <code>Promise</code> que se resuelve a true cuando el movimiento ha
            terminado.
          </p>
          <p>
            Pero, si el movimiento del sprite se interrumpe por un nuevo
            movimiento o una colisi√≥n que cambia significativamente la
            trayectoria del sprite, la promesa se resolver√° a false.
          </p>
        </md>
        <script type="mie/p5" id="random-sequence" horiz="" lines="17">
let turtle, ball;

function setup() {
	new Canvas(160, 304);
	turtle = new Turtle(30);
	ball = new Sprite(80, 152, 50);

	randomSequence();
}

async function randomSequence() {
	let x = random(0, width);
	let y = random(0, height);
	await turtle.rotateTo(x, y, 5);
	await turtle.moveTo(x, y, 3);
	randomSequence();
}

function draw() {
	clear();
}
			</script>
      </div>
      <div id="page-9" class="page">
        <md id="md9-0"><h2 id="atributos-f√≠sicos">Atributos f√≠sicos</h2>
          <p>
            Los Sprites tienen atributos f√≠sicos que afectan c√≥mo interact√∫an
            con el mundo. Echa un vistazo a los mini-ejemplos para ver estos
            atributos en acci√≥n.
          </p>
        </md>
        <script type="mie/p5" base-6="" hide="">
let sprite, floor;
function setup() {
	new Canvas(238, 100);
	world.gravity.y = 10;
	sprite = new Sprite(26, 0, 40, 40);
	floor = new Sprite(119, 88, 238, 5, 's');
	floor.rotation = 5;
}
function draw() {
	clear();
}
			</script>
        <script type="mie/p5" base-7="" hide="">
let sprite, floor;
function setup() {
	new Canvas(238, 100);
	world.gravity.y = 10;
	sprite = new Sprite(26, 0, 40);
	floor = new Sprite(119, 88, 238, 5, 's');
	floor.rotation = 5;
}
function draw() {
	clear();
}
			</script>
        <div class="minis">
          <script type="mie/p5" id="low-bounciness" base="7">
sprite.bounciness = 0.5;
				</script>
          <script type="mie/p5" id="full-bounciness" base="7">
sprite.bounciness = 1;
				</script>
        </div>
        <div class="minis">
          <script type="mie/p5" id="0-friction" base="6">
sprite.friction = 0;
				</script>
          <script type="mie/p5" id="high-friction" base="6">
sprite.friction = 10;
				</script>
          <script type="mie/p5" id="0-drag" base="6">
sprite.drag = 0;
				</script>
          <script type="mie/p5" id="high-drag" base="6">
sprite.drag = 10;
				</script>
        </div>
        <div class="minis">
          <script type="mie/p5" id="low-rotationDrag" base="7">
sprite.rotationDrag = 1;
				</script>
          <script type="mie/p5" id="high-rotationDrag" base="7">
sprite.rotationDrag = 5;
				</script>
          <script type="mie/p5" id="no-rotationLock" base="7">
sprite.rotationLock =false
				</script>
          <script type="mie/p5" id="with-rotationLock" base="7">
sprite.rotationLock = true;
				</script>
        </div>
        <div class="break"></div>
        <md id="md9-1"><h2 id="¬°pru√©balo">¬°Pru√©balo!</h2>
          <p>
            Por defecto, la <code>mass</code> se asigna en funci√≥n del tama√±o
            del sprite. Cuanto mayor sea el sprite, m√°s masa tendr√°. La masa
            tambi√©n puede ser ajustada manualmente.
          </p>
          <p>
            Intenta cambiar la masa de uno de los sprites en este mini-ejemplo.
          </p>
        </md>
        <script type="mie/p5" id="mass" lines="13">
let platform, pin, a, b;
function setup() {
	new Canvas(238, 100);
	world.gravity.y = 10;

	platform = new Sprite(121, 88, 232, 5);
	pin = new Sprite(121, 93, 5, 's');

	a = new Sprite(26, 0, 40, 40);
	a.mass = 2;
	b = new Sprite(216, 0, 40, 40);
	b.mass = 2;
}
function draw() {
	clear();
}
			</script>
        <div class="break"></div>
        <md id="md9-2"><h2 id="bugs-en-planck">Bugs en planck</h2>
          <p>
            p5play usa el motor de f√≠sica planck, que normalmente ofrece
            interacciones f√≠sicas de apariencia realista, pero no es perfecto.
          </p>
          <p>
            En este mini-ejemplo, la bola tiene una <code>bounciness</code> de
            1, as√≠ que cada vez que la bola rebota deber√≠a volver a su posici√≥n
            inicial. Sin embargo, debido a un bug en planck, la bola rebota cada
            vez m√°s alto cada vez que golpea el suelo.
          </p>
        </md>
        <script type="mie/p5" id="full-bounce-error" lines="10" horiz="">
let ball, ground;
function setup() {
	new Canvas(32, 192);
	world.gravity.y = 10;

	ball = new Sprite(16, 100, 8);
	ball.bounciness = 1;

	ground = new Sprite(16, 184, 32, 16, 's');
}

function draw() {
	background(0);

	fill(100);
	for (let i = 0; i < width / 32; i++) {
		for (let j = 0; j < height / 32; j++) {
			rect(i * 32, j * 32, 32, 32);
		}
	}
}
			</script>
        <md id="md9-3"><p>
            Esperemos que el bug se solucione en una futura versi√≥n de planck o
            p5play, pero hasta entonces aqu√≠ tienes una soluci√≥n alternativa.
          </p>
          <p>
            El bug de <code>bounciness</code> es m√°s notorio cuando un
            colisionador rebota en una superficie plana. Aqu√≠ tienes una
            soluci√≥n alternativa que sobrescribe la velocidad y de la bola
            despu√©s de que colisiona con el suelo.
          </p>
        </md>
        <script type="mie/p5" id="full-bounce-workaround" horiz="">
let ball, ground;
function setup() {
	new Canvas(32, 192);
	world.gravity.y = 10;

	ball = new Sprite(16, 100, 8);
	ball.bounciness = 1;

	ground = new Sprite(16, 184, 32, 16, 's');
}

function draw() {
	clear();

	if (ball.collided(ground)) {
		ball.vel.y = -4.8;
	}
}
			</script>
        <md id="md9-4"><p>
            En este ejemplo, el color del bloque es rojo cuando est√°
            colisionando con la plataforma m√≥vil. Aunque podr√≠as esperar que el
            bloque se mantenga rojo mientras est√° siendo levantado por la
            plataforma, parpadea entre rojo y azul.
          </p>
          <p>
            En la vida real, cuando una persona sube a un ascensor y este sube,
            dir√≠amos que esa persona estar√≠a colisionando con el suelo del
            ascensor durante todo el trayecto.
          </p>
          <p>
            En planck, sin embargo, cuando los colisionadores son desplazados
            por otros colisionadores, constantemente colisionan y dejan de
            colisionar entre s√≠.
          </p>
          <p>
            Si est√°s intentando hacer un juego de plataformas (como Super Mario
            Bros.), el 'colliding' no es una manera confiable de verificar si un
            sprite est√° parado en una plataforma. Echa un vistazo a mi
            <a href="https://openprocessing.org/sketch/1869796">demostraci√≥n de plataformas</a>.
          </p>
        </md>
        <script type="mie/p5" id="colliding-bug" horiz="">
let block, platform;

function setup() {
	new Canvas(60, 400);
	world.gravity.y = 10;

	block = new Sprite(30, 30);
	platform = new Sprite(30, 200, 60, 5, 'k');
	platform.color = 'red';
}

function draw() {
	clear();
	platform.vel.y = cos(frameCount * 2.2) * 6;

	if (block.colliding(platform)) {
		block.color = 'red';
	} else {
		block.color = 'blue';
	}
}

			</script>
      </div>
      <div id="page-10" class="page">
        <md id="md10-0"><h2 id="colisionadores-de-cadena">Colisionadores de Cadena</h2>
          <p>
            Hay tres modos de cadena diferentes: v√©rtice, distancia y l√≠nea.
          </p>
          <p>
            Para usar el modo v√©rtice, proporciona al constructor Sprite un
            array de arrays de v√©rtices. Cada array de v√©rtices debe contener
            coordenadas [x, y]. En estos mini-ejemplos, la posici√≥n (x, y) del
            sprite est√° resaltada por un peque√±o cuadrado negro.
          </p>
          <p>
            ¬°Intenta cambiar los v√©rtices del sprite de cadena en el
            mini-ejemplo para que la bola se quede en el suelo!
          </p>
        </md>
        <script type="mie/p5" id="vertex-mode" lines="12">
let floor, ball;

function setup() {
	new Canvas(500, 200);
	world.gravity.y = 10;

	//                ([vertex0, vertex1, vertex2, ...])
	floor = new Sprite([[20, 60], [200, 140], [450, 180]]);
	floor.collider = 'static';

	ball = new Sprite(40, 0, 20);
}

function draw() {
	clear();
	rect(floor.x - 2, floor.y - 2, 4, 4);
}
			</script>
        <md id="md10-1"><p>
            Para usar el modo distancia, proporciona al constructor Sprite una
            posici√≥n (x, y) y un array de arrays de distancia. Estos arrays
            deben contener distancias [x, y] relativas al v√©rtice anterior. La
            posici√≥n (x, y) ser√° el primer v√©rtice de la cadena.
          </p>
          <p>El modo distancia es el mejor para crear cadenas s√∫per largas.</p>
          <p>
            Intenta a√±adir 5 distancias para hacer que el suelo suba y baje en
            una cadena de suelo rocoso.
          </p>
        </md>
        <script type="mie/p5" id="distance-mode" lines="12">
let ground, ball;

function setup() {
	new Canvas(500, 200);
	world.gravity.y = 10;

	//                 (x, y, [distance0, distance1, ...])
	ground = new Sprite(30, 90, [[20, 20], [60, -10], [50, 10]], 'static');

	ball = new Sprite(40, 0, 20);
}
	
function draw() {
	clear();
	rect(ground.x - 2, ground.y - 2, 4, 4);
}
			</script>

        <md id="md10-2"><p>
            Para usar el modo l√≠nea, proporciona al constructor Sprite una
            posici√≥n (x,y) y una lista de longitudes de l√≠nea y √°ngulos. Cada
            √°ngulo es relativo al √°ngulo de la l√≠nea anterior.
          </p>
          <p>
            Es mejor usar el modo l√≠nea para cadenas peque√±as y/o sim√©tricas.
          </p>
          <p>
            Nota que la posici√≥n (x, y) de la cadena del modo l√≠nea se ubica en
            el promedio de todos sus v√©rtices, lo cual puede no ser un punto en
            la cadena.
          </p>
          <p>¬°Intenta cambiar las longitudes de estas l√≠neas y sus √°ngulos!</p>
        </md>
        <script type="mie/p5" id="line-mode" lines="12">
let shelf, orb;

function setup() {
	new Canvas(500, 200);
	world.gravity.y = 10;

	//                (x, y, [length0, angle0, length1, ...])
	shelf = new Sprite(250, 100, [50, 20, 50, -20, 50, -20], 'static');

	orb = new Sprite(200, 0, 20);
}
	
function draw() {
	clear();
	rect(shelf.x - 2, shelf.y - 2, 4, 4);
}
			</script>
      </div>
      <div id="page-11" class="page">
        <md id="md11-0"><h2 id="colisionadores-de-pol√≠gonos">Colisionadores de Pol√≠gonos</h2>
          <p>
            Los pol√≠gonos regulares pueden crearse proporcionando al constructor
            Sprite una longitud de lado y el nombre del pol√≠gono.
          </p>
          <p>
            Estos son los nombres que puedes usar: tri√°ngulo, cuadrado,
            pent√°gono, hex√°gono, sept√°gono, oct√°gono, ene√°gono, dec√°gono,
            hendec√°gono y dodec√°gono.
          </p>
        </md>
        <script type="mie/p5" id="pentagon" lines="6">
function setup() {
	new Canvas(500, 200);

	//        ( x,  y, sideLength, polygonName)
	new Sprite(250, 100, 80, 'pentagon');
}
	
function draw() {
	clear();
}
			</script>
        <md id="md11-1"><p>
            Si el inicio y el final de una cadena est√°n en el mismo punto y la
            forma resultante es convexa, ¬°se convierte autom√°ticamente en un
            pol√≠gono!
          </p>
        </md>
        <script type="mie/p5" id="irregular-polygon:-vertex-mode" lines="5">
function setup() {
	new Canvas(500, 200);

	new Sprite([[8, 8], [140, 192], [300, 90], [8, 8]]);
}

function draw() {
	clear();
}
			</script>
        <md id="md11-2"><p>
            Independientemente de si un sprite es un pol√≠gono o una cadena,
            todos los cuerpos f√≠sicos que comienzan y terminan en el mismo punto
            tienen su posici√≥n (x, y) ubicada en el centro de la forma, no en el
            primer v√©rtice. Esta posici√≥n se calcula promediando todos los
            v√©rtices de la forma.
          </p>
        </md>
        <script type="mie/p5" id="irregular-polygon:-distance-mode" lines="9">
function setup() {
	new Canvas(500, 200);

	new Sprite(250, 100, [
		[100, 40],
		[-100, 40],
		[0, -80]
	]);
}

function draw() {
	clear();
}
			</script>
        <md id="md11-3"><p>
            Puedes forzar a que un pol√≠gono convexo sea una cadena estableciendo
            <code>sprite.shape = 'chain'</code>
          </p>
          <p>
            Los pol√≠gonos regulares pueden crearse a partir de una lista con la
            longitud de l√≠nea, √°ngulo y repetici√≥n.
          </p>
          <p>
            La f√≥rmula para el √°ngulo de un pol√≠gono regular es 360 / n, donde n
            es el n√∫mero de lados. Haz que ese √°ngulo sea negativo para orientar
            el pol√≠gono con uno de sus bordes en la parte superior.
          </p>
          <p>¬°Intenta hacer una cadena en forma de cuadrado!</p>
        </md>
        <script type="mie/p5" id="pentagon-chain" lines="7">
function setup() {
	new Canvas(500, 200);

	//               (x, y, [length, angle, repeat])
	let s = new Sprite(250, 100, [80, -72, 5]);
	s.shape = 'chain';
}
	
function draw() {
	clear();
}
			</script>
        <md id="md11-4"><p>
            Aqu√≠ est√° el c√≥digo para hacer una estrella regular con cinco
            puntos.
          </p>
          <p>
            Nota que debido a que la estrella es una forma c√≥ncava, no puede
            tener un colisionador de pol√≠gono.
          </p>
          <p>¬°Intenta cambiar el n√∫mero de puntos!</p>
        </md>
        <script type="mie/p5" id="star" lines="6">
function setup() {
	new Canvas(500, 200);

	//        ( x,  y, [l0, a0, l1, a1, repeat])
	new Sprite(250, 100, [60, -72, 60, 144, 5]);
}

function draw() {
	clear();
}
			</script>
        <md id="md11-5"><p>¬°Ahora puedes ver c√≥mo se hizo el logotipo de p5play!</p>
          <p>
            Incluso las cadenas cerradas como esta est√°n hechas de l√≠neas y
            est√°n vac√≠as por dentro. En el ejemplo de la p√°gina principal de
            p5play, puedes ver c√≥mo los colisionadores de cadena pueden contener
            muchos otros sprites dentro de ellos!
          </p>
        </md>
        <script type="mie/p5" id="p5play-logo" lines="8">
function setup() {
	new Canvas(500, 200);
	world.gravity.y = 10;

	new Sprite(250, 100, [40, 72, 40, -72, 40, 72, 5], 's');

	new Sprite(251, 50, 20, 'pentagon');
}

function draw() {
	clear();
}
			</script>
        <md id="md11-6"><p>
            Nota que los colisionadores de cadena cerrada no son tan buenos para
            ser colisionadores din√°micos. Esta es una limitaci√≥n del motor de
            f√≠sica Box2D que utiliza p5play.
          </p>
        </md>
        <script type="mie/p5" id="concave-chain-colliders" lines="11">
function setup() {
	new Canvas(500, 200);
	world.gravity.y = 10;

	new Sprite([
		[200, 50],
		[300, 50],
		[300, 100],
		[280, 70],
		[200, 50]
	]);

	new Sprite(250, 190, 500, 10, 's');
}

function draw() {
	clear();
}
			</script>
      </div>
      <div id="page-12" class="page">
        <div class="minis horiz">
          <md id="md12-0"><h2 id="dibujo-personalizado">Dibujo personalizado</h2>
            <p>
              A veces no podr√°s usar animaciones predibujadas para obtener el
              tipo de efecto visual que quieres para un sprite en movimiento.
            </p>
            <p>
              Afortunadamente, puedes personalizar la funci√≥n
              <code>draw</code> del sprite y hacer que muestre cualquier cosa
              que quieras!
            </p>
            <p>
              Ten en cuenta que dentro de la funci√≥n de dibujo del sprite, el
              centro del sprite se traduce a la posici√≥n (0, 0).
            </p>
            <p>
              Este mini ejemplo rota la elipse del sprite en la direcci√≥n en la
              que se est√° moviendo y hace que la elipse se estire en esa
              direcci√≥n proporcionalmente a su velocidad. ¬°Un poco complicado!
            </p>
          </md>
          <md id="md12-1"><h2 id="actualizaci√≥n-personalizada">
              Actualizaci√≥n personalizada
            </h2>
            <p>
              Tambi√©n puedes definir una funci√≥n <code>update</code> de
              actualizaci√≥n personalizada para un sprite que se ejecuta al final
              del bucle de dibujo o cuando se llama a updateSprites. Puedes
              poner cualquier comportamiento espec√≠fico del sprite que quieras
              all√≠.
            </p>
          </md>
        </div>
        <script type="mie/p5" id="custom-draw">
let face, stretchy;

function setup() {
	new Canvas(500, 200);

	face = loadImage('/learn/assets/face.png');
	stretchy = new Sprite();
	
	stretchy.draw = () => {
		fill(237, 205, 0);

		push();
		rotate(stretchy.direction);
		ellipse(0, 0, 100 + stretchy.speed, 100 - stretchy.speed);
		pop();

		image(face, stretchy.vel.x * 2, stretchy.vel.y * 2);
	};

	stretchy.update = () => {
		stretchy.moveTowards(mouse, 0.07);
	};
}

function draw() {
	clear();
}
//
			</script>
      </div>
      <div id="page-13" class="page">
        <md id="md13-0"><h2 id="escala">escala</h2>
          <p>
            Cambiar <code>sprite.scale</code> escalar√° el colisionador del
            sprite y la apariencia visual por la cantidad especificada.
          </p>
          <p>
            Presiona una tecla num√©rica para ver el sprite escalar uniformemente
            por esa cantidad.
          </p>
          <p>Presiona "d" para duplicar la escala del sprite.</p>
          <p>
            Presiona "x" o "y" para escalar el sprite en esa direcci√≥n por una
            cantidad aleatoria. Pero ten en cuenta que si el sprite se escala de
            manera desigual, la imagen se distorsionar√° y permanecer√° as√≠
            incluso cuando se escale uniformemente de nuevo.
          </p>
        </md>
        <script type="mie/p5" id="scaling">
let sprite;

function setup() {
	new Canvas(500, 200);

	sprite = new Sprite(250, 100, 90, 90);
	sprite.img = '/learn/assets/square.png';
	sprite.debug = true;
}

function draw() {
	clear();

	for (let i = 1; i < 10; i++) {
		if (kb.presses(i)) sprite.scale = i;
	}

	if (mouse.presses()) sprite.scale *= 2;
	if (kb.presses('x')) sprite.scale.x = random(0.1, 6);
	if (kb.presses('y')) sprite.scale.y = random(0.1, 6);

	if (kb.pressing('a')) sprite.ani.scale.x = 10;
	else sprite.ani.scale.x = 1;
}
			</script>
      </div>
      <div id="page-14" class="page">
        <div class="minis">
          <md id="md14-0"><h2 id="colisionadores-combo">Colisionadores Combo</h2>
            <p>
              Usando la funci√≥n <code>addCollider</code>, puedes agregar varios
              colisionadores a un sprite.
            </p>
            <p>
              ¬°Pero solo usa esta funci√≥n cuando realmente sea necesario para el
              juego! Normalmente, si algo requiere muchos colisionadores, como
              las paredes de un laberinto, simplemente deber√≠as crear varios
              sprites, cada uno con su propio colisionador. Adem√°s, incluso si
              la imagen de un sprite es compleja, t√≠picamente una caja o c√≠rculo
              ser√° suficiente para las interacciones f√≠sicas, especialmente para
              sprites peque√±os.
            </p>
            <p>
              Sin embargo, a veces, realmente necesitar√°s crear un sprite con
              varios colisionadores. ¬°Por ejemplo, si quieres modelar un flipper
              de pinball!
            </p>
          </md>
          <md id="md14-1"><h2 id="sensores-de-combinaci√≥n">Sensores de Combinaci√≥n</h2>
            <p>
              Los sensores de superposici√≥n determinan si un sprite se superpone
              con otro sprite.
            </p>
            <p>
              Por defecto, cuando se utiliza un m√©todo de verificaci√≥n de
              superposici√≥n y el sprite no tiene sensores, se utiliza la funci√≥n
              <code>addDefaultSensors</code> en segundo plano para crear
              sensores para cada uno de los colisionadores del sprite.
            </p>
            <p>
              Puedes agregar sensores adicionales a un sprite utilizando la
              funci√≥n <code>addSensor</code>.
            </p>
          </md>
        </div>
        <script type="mie/p5" id="pinball-flipper" horiz="">
let ball, flipper;

function setup() {
	new Canvas(196, 500);
	world.gravity.y = 10;

	ball = new Sprite(100, -20, 30);

	flipper = new Sprite(160, 400, [
		[0, -25],
		[-100, 12.5],
		[0, 25],
		[100, 12.5],
		[0, -25]
	], 'k');

	flipper.addCollider(-60, 0, 25);
	flipper.addCollider(40, 0, 50);
	
	flipper.offset.x = -40;
	flipper.rotation = -20;
	flipper.debug = true;
}

function draw() {
	background(150);

	if (mouse.presses()) {
		flipper.rotateTo(20, 8);
	}
	if (mouse.pressed()) {
		flipper.rotateTo(-20, 8);
	}

	if (frameCount % 100 == 0) {
	  ball.life = 200;
		let x = random(50, 140);
		ball = new Sprite(x, -100, 30);
	}
}
			</script>
      </div>
      <div id="page-15" class="page">
        <md id="md15-0"><p>
            Si quieres que un sprite siga a otro sprite, es posible que te
            sientas tentado a usar <code>moveTo</code> repetidamente sin esperar
            a que el sprite alcance su destino. Sin embargo, para obtener un
            mejor rendimiento, prueba a utilizar la funci√≥n
            <code>angleTo</code>, que obtiene el √°ngulo entre un sprite y una
            posici√≥n. Este √°ngulo se puede utilizar para cambiar la direcci√≥n en
            la que se mueve el sprite.
          </p>
          <p>
            En este ejemplo, se utiliza la funci√≥n
            <a href="https://p5js.org/reference/#/p5/dist">dist</a> de p5.js
            para calcular la distancia entre el jugador y su aliado.
          </p>
        </md>
        <script type="mie/p5" base-8="" hidden="">
let player, ally;

function setup() {
	new Canvas(500, 100);
	player = new Sprite(400, 50, 20);
	ally = new Sprite(200, 50, 20, 20, 'n');
}

function draw() {
	clear();
}
        </script>
        <script type="mie/p5" id="angleTo" base="8">
player.moveTowards(mouse);

let distance = dist(player.x, player.y, ally.x, ally.y);

if (distance > 40) {
  ally.direction = ally.angleTo(player);
  ally.speed = 2;
} else if (distance < 30) {
  ally.speed = 0;
}
      </script>
        <md id="md15-1"><p>
            Las funciones move anulan las velocidades de un sprite, pero ¬øqu√©
            pasa si quieres que un sprite respete otras fuerzas que act√∫an sobre
            √©l, como la gravedad?
          </p>
          <p>
            Puedes sumar o restar directamente a las velocidades de un sprite, o
            usar las funciones <code>applyForce</code>.
          </p>
        </md>
        <script type="mie/p5" id="applyForce" horiz="">
let player;

function setup() {
  new Canvas(160, 400);
  world.gravity.y = 10;
  player = new Sprite(150, 50, 10);
  new Sprite(2, 200, 4, 400, 's');
}

function draw() {
  clear();

  if (mouse.pressing()) {
    player.applyForce(-5, 0);
  }

  if (player.y > 400) {
    player.pos = {x: 150, y: 0};
    player.speed = 0;
  }
}
      </script>
      </div>

      <div class="break"></div>
      <div id="toc">
        <a id="prevPage" class="navLink">P√°gina anterior</a>
        <div id="pageNav" class="submenu">
          <a data-page="0" href="sprite.html?page=0">Propiedades B√°sicas</a>
          <a data-page="1" href="sprite.html?page=1">F√≠sica</a>
          <a data-page="2" href="sprite.html?page=2">Movimiento</a>
          <a data-page="3" href="sprite.html?page=3">Sprites con Im√°genes</a>
          <a data-page="4" href="sprite.html?page=4">Constructor de Sprite</a>
          <a data-page="5" href="sprite.html?page=5">Colisiones</a>
          <a data-page="6" href="sprite.html?page=6">Superposiciones</a>
          <a data-page="7" href="sprite.html?page=7">Rotaci√≥n</a>
          <a data-page="8" href="sprite.html?page=8">Secuenciaci√≥n de Movimiento</a>
          <a data-page="9" href="sprite.html?page=9">Atributos F√≠sicos</a>
          <a data-page="10" href="sprite.html?page=10">Cadenas</a>
          <a data-page="11" href="sprite.html?page=11">Pol√≠gonos</a>
          <a data-page="12" href="sprite.html?page=12">Dibujo Personalizado</a>
          <a data-page="13" href="sprite.html?page=13">Escalado</a>
          <a data-page="14" href="sprite.html?page=14">Combos de Colisionadores</a>
          <a data-page="15" href="sprite.html?page=15">Movimiento Avanzada</a>
        </div>
        <a id="nextPage" class="navLink">Siguiente p√°gina</a>
      </div>
      <div class="break"></div>
      <footer id="credits" class="text-small">
        Creado por Quinton Ashley (@quinton-ashley) derechos de autor 2022-2023
      </footer>
    </article>

    <!-- <script src="https://cdn.jsdelivr.net/npm/p5@1/lib/p5.min.js"></script> -->
    <script src="/v3/q5.min.js"></script>
    <script src="/v3/planck.min.js"></script>
    <script src="/v3/p5play.min.js"></script>
    <script>
      window.mie = { autoLoad: false };
    </script>
    <script src="/learn/mie.js"></script>
    <script src="/learn/learn.js"></script>
  

</body></html>