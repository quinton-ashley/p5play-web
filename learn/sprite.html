<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>p5play : Sprite</title>
	<link rel="icon" href="/assets/p5play_logo.svg">
	<link rel="stylesheet" href="/learn/style.css">
</head>

<body class="dark">
	<article style="display: none;">
		<nav id="topNav">
			<a href="index.html" class="logoLink active">
				<img alt="p5play logo" src="/assets/p5play_logo.svg" class="p5play_logo">
				<span>p5play</span>
			</a>
			<hr>
			<a href="sprite.html" class="active">Sprite</a>
			<a href="group.html">Group</a>
			<a href="animation.html">Ani</a>
			<a href="input.html">Input</a>
			<a href="camera.html">Camera</a>
			<a href="joints.html">Joints</a>
			<a href="canvas.html">...</a>
			<hr>
			<a id="darkMode" onclick="toggleDarkMode()" tabindex="0" role="button" title="dark mode toggle">
				<div id="darkModeIcon"></div>
			</a>
		</nav>

		<div class="break"></div>

		<div id="page-0" class="page">
			<md id="md0-0">
				<h2 id="setup-and-draw">Setup and Draw</h2>
				<p>The code inside the <a href="https://q5js.org" target="_blank">q5.js</a> (or <a href="https://p5js.org"
						target="_blank">p5.js</a>) <code>setup</code> function runs when the
					program starts. The <code>new Canvas()</code> constructor creates a section of the screen that the
					program can draw on.</p>
				<p>The q5 <code>draw</code> function is run 60 times per second by default. The <code>background</code>
					function can be used to fill the canvas with a color each time it is drawn.</p>
				<p>Try changing the width and height of the canvas (the numbers inside the <code>Canvas</code>
					constructor), then restart the example program!</p>
			</md>
			<script type="mie/p5" id="setup-and-draw">
function setup() {
	new Canvas(250, 100);
}

function draw() {
	background('blue');
}
			</script>
			<div class="break"></div>
			<md id="md0-1">
				<h2 id="what-is-a-sprite">What is a sprite?</h2>
				<p>A sprite is a ghost!</p>
				<p>Video game developers use the word "sprite" to refer to characters, items, or anything else that
					moves above a background.</p>
				<p>The <code>new Sprite()</code> constructor creates a sprite object, which contains variables that
					define a sprite‚Äôs position, size, and appearance.</p>
				<p>Try editing the properties of the box and circle sprites in the code examples below!</p>
			</md>
			<div class="minis horiz">
				<script type="mie/p5" id="box" base-0="" horiz="" lines="9">
let sprite;

function setup() {
	new Canvas(238, 100);

	sprite = new Sprite();
	sprite.width = 50;
	sprite.height = 50;
}

function draw() {
	clear();
}
				</script>
				<script type="mie/p5" id="circle" base-1="" horiz="" lines="8">
let sprite;

function setup() {
	new Canvas(238, 100);

	sprite = new Sprite();
	sprite.diameter = 50;
}

function draw() {
	clear();
}
				</script>
			</div>
			<div class="minis">
				<script type="mie/p5" id="x">
sprite.x = 175;
				</script>
				<script type="mie/p5" id="y" base="1">
sprite.y = 30;
				</script>
				<script type="mie/p5" id="color" base="1">
sprite.color = 'pink';
sprite.stroke = 'red';
				</script>
				<script type="mie/p5" id="rotation">
sprite.rotation = 45;
				</script>
			</div>

			<div class="minis">
				<script type="mie/p5" id="width">
sprite.w = 200;
				</script>
				<script type="mie/p5" id="height">
sprite.h = 80;
				</script>
				<script type="mie/p5" id="diameter" base="1">
sprite.d = 40;
				</script>
				<script type="mie/p5" id="textSize">
sprite.textSize = 40;
sprite.text = "p5";
				</script>
			</div>
			<div class="break"></div>
			<div class="minis horiz">
				<md id="md0-2">
					<h2 id="try-it">Try it!</h2>
					<p>Try turning the sprite named <code>ball</code> into a blue circle with a diameter of 30 and place
						it at the top right corner of the canvas.</p>
				</md>
				<script type="mie/p5" id="Level-0-Challenge-Solution" hide-editor="">
let ball;

function setup() {
	new Canvas(500, 60);
	ball = new Sprite();
	ball.diameter = 30;
	ball.color = 'blue';
	ball.x = 480;
	ball.y = 16;
}

function draw() {
	clear();
}
				</script>
			</div>
			<script type="mie/p5" id="Level-0-Challenge" lines="13" horiz="">
let ball;

function setup() {
	new Canvas(200, 256);
	ball = new Sprite();
	// write your code here!
  
}

function draw() {
	clear();
}
			</script>
		</div>
		<div id="page-1" class="page">
			<md id="md1-0">
				<h2 id="sprite-physics">Sprite physics</h2>
				<p>A sprite's collider is used to detect collisions with other
					sprites. By default, sprites have a <code>'dynamic'</code> physics
					collider that allows the sprite to move freely and be affected by
					gravity.</p>
				<p><code>'static'</code> colliders can't be moved. <code>'kinematic'</code> colliders can be moved
					programmatically but not by other sprites. They also won't collide with other kinematic colliders.
					Setting a sprite's collider
					type to <code>'none'</code> makes it have no collider.</p>
				<p>The collider type can also be set using the first letter of the collider type name: <code>'d'</code>,
					<code>'s'</code>, <code>'k'</code>, or <code>'n'</code>.
				</p>
				<p>Click the reload icon on the top right corner of a code example to replay it!</p>
			</md>
			<script type="mie/p5" id="dynamic-and-static-colliders" base-2="" horiz="" lines="16">
let ball, floor;

function setup() {
	new Canvas(238, 200);
	world.gravity.y = 10;

	ball = new Sprite();
	ball.diameter = 50;
	ball.y = 30;

	floor = new Sprite();
	floor.y = 190;
	floor.w = 238;
	floor.h = 5;
	floor.collider = 'static';
}

function draw() {
	clear();
}
			</script>
			<div class="minis">
				<script type="mie/p5" id="anti-gravity" base="2">
world.gravity.y = -1;
				</script>
				<script type="mie/p5" id="sloped-floor" base="2">
floor.rotation = 2;
				</script>
			</div>

			<div class="minis">
				<script type="mie/p5" id="rising-platform" base="2">
floor.collider = 'k';
floor.velocity.y = -1;
				</script>
				<script type="mie/p5" id="whoops!" base="2">
floor.collider = 'none';
				</script>
			</div>
			<div class="break"></div>
			<div class="minis horiz">
				<md id="md1-1">
					<h2 id="try-it">Try it!</h2>
					<p>Try creating a sprite named <code>peg</code> with a static collider and circle shape. Create a
						sprite <code>block</code> with a dynamic collider and box shape. Position the block so that it
						hits the peg and falls to the right.</p>
					<p>Each time the q5 <code>draw</code> function finishes, sprites are automatically drawn and
						updated. Note that <code>world</code> is created when p5play loads but by default there's no
						gravity. Try setting <code>world.gravity.y</code> to a positive number.</p>
					<p>For an extra challenge, try resetting the block to its original position after it falls.</p>
				</md>
				<script type="mie/p5" id="Level-1-Challenge-Solution" hide-editor="">
let peg, block;

function setup() {
	new Canvas(460, 60);
	world.gravity.y = 10;

	peg = new Sprite();
	peg.diameter = 10;
	peg.y = 40;
	peg.collider = 'static';

	block = new Sprite();
	block.w = 30;
	block.h = 30;
	block.x = 236;
	block.y = 0;
}

function draw() {
	clear();
}
				</script>
			</div>
			<script type="mie/p5" id="Level-1-Challenge" lines="13" horiz="">
let peg, block;

function setup() {
	new Canvas(200, 364);

}

function draw() {
	clear();
}
			</script>
		</div>
		<div id="page-2" class="page">
			<md id="md2-0">
				<h2 id="sprites-with-an-image">Sprites with an Image</h2>
				<p><code>sprite.image</code> (aka <code>sprite.img</code>) can be set to a Q5.Image or a url path to an
					image file.</p>
				<p>If you need an image to be loaded before your program starts, it's best to use <a
						href="https://p5js.org/reference/p5/loadImage" target="_blank"><code>loadImage</code></a> inside
					the q5 <code>preload</code> function.</p>
				<p><code>sprite.image.offset</code> can be used to offset the image relative to the sprite's center.
					This can help better align the image with the sprite's physics collider.</p>
				<p><code>sprite.image.scale</code> changes the display size of the sprite's image. The default is 1.0.
					If the image appears way too big or small, you should probably change the size of the image file
					itself.</p>
				<p>Try clicking on the canvas of this example. When the <code>sprite.debug</code> property is set to
					true you can see the sprite's physics body collider.</p>
			</md>
			<script type="mie/p5" id="image">
let monster;

function setup() {
	new Canvas(500, 120);

	monster = new Sprite();
	monster.diameter = 70;
	monster.image = 'assets/monster.webp';
	monster.image.offset.y = 6;
}

function draw() {
	clear();
	monster.debug = mouse.pressing();
}
			</script>
			<div class="break"></div>
			<md id="md2-1">
				<h2 id="emoji-sprites">Emoji Sprites</h2>
				<p>No images? ü´• No problem! üòÑ</p>
				<p>You can use any emoji as the image for your sprite.</p>
				<p>The size of the emoji image will be based on the sprite's size. Great for quick prototyping! üß™</p>
			</md>
			<script type="mie/p5" id="emoji image" lines="8" horiz="">
function setup() {
	new Canvas(160, 160);

	let painting = new Sprite();
	painting.width = 100;
	painting.height = 100;
	painting.image = 'üñºÔ∏è';
}

function draw() {
	noLoop();
}
			</script>
			<div class="break"></div>
			<div class="minis">
				<md id="md2-2">
					<h2 id="pixel-art">Pixel Art</h2>
					<p>You can use the <code>spriteArt</code> function to create pixel art images for your sprites. It
						takes a string as input and returns an image. Each character in the string represents the color
						value of a pixel in the image.</p>
					<p>The second input parameter to the <code>spriteArt</code> function is the scale of the image.</p>
				</md>
				<md id="md2-3">
					<h2 id="try-it">Try it!</h2>
					<p>Try making your own pixel art! Take a look at the alphabet below to see what color each letter
						represents by default.</p>
				</md>
			</div>
			<script type="mie/p5" id="smiley" lines="15">
let smiley;

function setup() {
	new Canvas(500, 120);
	let smileText = `
..yyyyyy
.yybyybyy
yyyyyyyyyy
yybyyyybyy
.yybbbbyy
..yyyyyy`;

	smiley = new Sprite();
	smiley.img = spriteArt(smileText, 32);
}

function draw() {
  noLoop();
}
			</script>
			<div style="width: 100%; padding: 0">
				<script type="mie/p5" id="default-colors" hide-editor="">
function setup() {
	new Canvas(1030, 70);
	let alphaText = `
....b.........d......ff.....h....i...j..k....l...............................t.....................
.aa.bbb.ccc.ddd.ee...f..ggg.hhh.........k.k..l..mmm.nnn.ooo.ppp.qqq.rrr..ss.ttt.u.u.v.v.x.x.y.y.zz
a.a.b.b.c...d.d.ee..fff.ggg.h.h..i...j..kk...l..mmm.n.n.o.o.p.p.q.q.r....s...t..u.u.v.v..x..yyy..z.
.aa.bbb.ccc.ddd.eee..f....g.h.h..i...j..k.k..ll.m.m.n.n.ooo.ppp.qqq.r...ss...tt.uuu..v..x.x...y..zz
........................ggg.........jj......................p.....q.........................yy.....
`;

	let alpha = new Sprite();
	alpha.img = spriteArt(alphaText, 20);

	background(20);
	noLoop();
}

function draw() {}

        </script>
			</div>
			<div class="break"></div>
			<md id="md2-4">
				<h2 id="custom-colors">Custom Colors</h2>
				<p>You can also make pixel art that uses custom colors by creating a color palette and passing it as the
					third parameter to the <code>spriteArt</code> function.</p>
				<p>Color palettes in p5play must be provided in <a href="https://p5js.org/reference/p5/object"
						target="_blank">JavaScript Object</a> format. A simple JS object is like a dictionary. You can
					define a color for each letter you use in your pixel art. To create a color use the q5 <a
						href="https://p5js.org/reference/p5/color" target="_blank"><code>color</code></a> function which
					accepts RGB (red, green, blue) values or HEX color codes.</p>
				<p>The easiest way to find colors is to use a <a href="https://www.google.com/search?q=google+color+picker"
						target="_blank">color picker</a>.</p>
			</md>
			<script type="mie/p5" id="blue-smiley" lines="20">
let smiley;

function setup() {
	new Canvas(500, 120);
	let smileText = `
..uuuuuu
.uubuubuu
uuuuuuuuuu
uubuuuubuu
.uubbbbuu
..uuuuuu`;

	let palette = {
		u: color(60, 220, 255),
		b: color('#303060')
	};

	smiley = new Sprite();
	smiley.img = spriteArt(smileText, 32, palette);
}

function draw() {
	noLoop();
}
			</script>
		</div>
		<div id="page-3" class="page">
			<script type="mie/p5" id="idle-player" lines="11" hide="" base-3="">
let player, block;
		
function setup() {
	new Canvas(500, 100);

	player = new Sprite();
	player.x = 400;
	player.diameter = 50;
	player.image = random('üòç ü•∞ üßê ü§ì üòé üòã üòâ ü§© ü•∏ üòØ üòµ‚Äçüí´'.split(' '));

	block = new Sprite();
	// colored box emoji
	block.image = random(['üü•', 'üü¶', 'üü©', 'üü®', 'üüß', 'üü™', 'üü´']);
}

function draw() {
	clear();
}
					</script>
			<md id="md3-0">
				<h2 id="sprite-movement">Sprite movement</h2>
				<p>Moving a sprite by directly editing its (x, y) coordinates will teleport it to the new position,
					without moving it through intermediate positions.</p>
				<p>Try clicking around this code example.</p>
			</md>
			<script type="mie/p5" id="teleport" base="3">
if (mouse.presses()) {
	player.x = mouse.x;
	player.y = mouse.y;
}
					</script>
			<md id="md3-1">
				<p>If you want a sprite to physically interact with other sprites while it's moving, don't teleport it!
				</p>
				<p>This bad example shows what happens if a sprite is teleported every time the p5.js draw function
					renders a frame.</p>
			</md>
			<script type="mie/p5" id="teleport-:-continuously-üëé" base="3">
player.x = mouse.x;
player.y = mouse.y;
					</script>
			<md id="md3-2">
				<p>All the other movement methods on this page change the sprite's <code>velocity</code>, aka
					<code>vel</code>, which is its rate of motion along the x and y axis.
				</p>
				<p><code>vel</code> is Q5.Vector, you can use any vector functions on it.</p>
				<p>Restart this example to see the player sprite hit the block!</p>
			</md>
			<script type="mie/p5" id="velocity-:-continuously" base="3">
player.vel.x = -2;
player.vel.y = 0.1;
					</script>
			<md id="md3-3">
				<p>Yet, you may find it's more convenient to move a sprite by setting its <code>direction</code> and
					<code>speed</code>.
				</p>
				<p>You can also set a sprite's direction using an angle value or direction name such as: 'up', 'down',
					'left', 'right', 'upLeft', 'upRight', 'downLeft', 'downRight'.</p>
			</md>
			<script type="mie/p5" id="direction-+-speed-:-continuously" base="3">
player.direction = 187;
player.speed = 3;
					</script>
			<md id="md3-4">
				<p>The <code>move</code> function moves a sprite across a fixed distance. The direction and speed of the
					movement can be specified as parameters to the function or set separately, like in the previous
					example.</p>
			</md>
			<script type="mie/p5" id="move-:-impulse" base="3">
if (kb.presses('left')) {
	//   (distance, direction, speed)
	player.move(30, 'left', 3);
}
					</script>
			<md id="md3-5">
				<p>The <code>moveTowards</code> function moves a sprite towards a position, at a percentage of the
					distance to that position.</p>
				<p>In this example, the player moves 10% of the distance to the mouse on every q5 <code>draw</code>
					call. Its speed, and the force it exerts on the block, is proportional to the distance it moves.</p>
			</md>
			<script type="mie/p5" id="moveTowards-:-continuously" base="3">
//                (x, y, tracking)
//                (position, tracking)
player.moveTowards(mouse, 0.10);
					</script>
			<md id="md3-6">
				<p>The <code>moveTo</code> function generates an impulse that moves a sprite to a position at a constant
					speed.</p>
				<p>But note that if the sprite is acted on by a force like gravity or bumps into another sprite, its
					speed and direction will be affected and it may not reach the target position.</p>
				<p>Any movement function that accepts an object with x and y properties could instead be called with (x,
					y) position numbers.</p>
			</md>
			<script type="mie/p5" id="moveTo-:-impulse" base="3">
if (mouse.presses()) {
	//           (x, y, speed)
	//           (position, speed)
	player.moveTo(mouse.x, mouse.y, 8);
}
					</script>
			<md id="md3-7">
				<p>Hopefully the examples on this page helped you understand some of the sprite movement options
					available in p5play!</p>
				<p>But, note that the <code>move</code>, <code>moveTo</code>, and <code>moveTowards</code> functions are
					imperative, they override a sprite's current motion, forcing it to move in a new direction. That may
					not always be what you want! Read the page on advanced sprite movement to learn how to move a sprite
					with respect to other forces acting on it, such as gravity.</p>
			</md>
			<script type="mie/p5" id="segmented-motion" base="3">
if (kb.pressing('left')) player.vel.x = -5;
else if (kb.pressing('right')) player.vel.x = 5;
else player.vel.x = 0;
			</script>
		</div>
		<div id="page-4" class="page">
			<div class="minis horiz">
				<md id="md4-0">
					<h2 id="create-sprites-faster">Create Sprites faster</h2>
					<p>Inside the Sprite constructor, <code>new Sprite()</code>, you can specify the sprite's position,
						size, and collider type.</p>
					<p>As you saw on the previous Sprite reference pages, you don't need to add any inputs to the Sprite
						constructor to create a sprite. But, if you do want to set a sprite's size in the constructor
						you'll need to specify its position first.</p>
					<p>By default, if no inputs are given to the Sprite constructor, a new sprite is positioned at the
						center of the canvas, with a width and height of 50 pixels, and a dynamic collider.</p>
				</md>
				<script type="mie/p5" id="default-sprite" lines="5" horiz="">
function setup() {
	new Canvas(100, 100);

	new Sprite();
}

function draw() {}
				</script>
			</div>
			<div class="minis horiz">
				<script type="mie/p5" id="Ooo!" horiz="" lines="18">
let box, circle;

function setup() {
	new Canvas(50, 200);
	world.gravity.y = 10;

	//             	( x,  y,  w,  h, collider)
	box = new Sprite(25, 70, 10, 90, 'static');
	// same as setting the values separately
	// box.x = 25;
	// box.y = 70;
	// box.width = 10;
	// box.height = 90;
	// box.collider = 'static';

	// 					 	     ( x,   y,  d, collider)
	circle = new Sprite(25, 140, 10, 'static');
}

function draw() {
	clear();
}
				</script>
				<script type="mie/p5" id="ball-on-the-floor" lines="10" horiz="">
let ball, floor;

function setup() {
	new Canvas(80, 160);
	world.gravity.y = 10;
	
	ball = new Sprite(40, 30, 50);

	floor = new Sprite(40, 155, 80, 5, 'static');
}

function draw() {
	clear();
}
				</script>
			</div>
			<div class="break"></div>
			<md id="md4-1">
				<h2 id="try-it">Try it!</h2>
				<p>Try creating two sprites using the sprite constructor.</p>
			</md>
			<script type="mie/p5" id="Level-4-Challenge" lines="13" horiz="">
let sprite1, sprite2;

function setup() {
	new Canvas(50, 256);

}

function draw() {
	clear();
}
			</script>
		</div>
		<div id="page-5" class="page">
			<md id="md5-0">
				<h2 id="collisions">Collisions</h2>
				<p>To check for collisions use these functions inside the q5 <code>draw</code> function.</p>
				<p>On the first frame that a sprite collides with another sprite, the <code>collides</code> function
					returns true.</p>
				<p>While a sprite is colliding with another sprite, the <code>colliding</code> function returns the
					number of frames the collision has occurred for.</p>
				<p>On the first frame after two sprites collided, the <code>collided</code> function returns true.</p>
			</md>
			<script type="mie/p5" id="pillar-stomp!" horiz="">
let player, pillar;

function setup() {
	new Canvas(60, 342);
	world.gravity.y = 10;
	
	pillar = new Sprite(30, 362, 30, 500, 'static')
	player = new Sprite(30, 0, 50);
}

function draw() {
	clear();

	if (player.collides(pillar)) {
		player.vel.y = -5;
		pillar.h -= 52;
	}
}
			</script>
			<script type="mie/p5" id="drop-block" horiz="">
let block, floor;

function setup() {
	new Canvas(60, 342);
	world.gravity.y = 10;
	
	block = new Sprite(30, 30);
	floor = new Sprite(30, 300, 60, 5, 'static');
	floor.color = 'red';
}

function draw() {
	clear();
	if (block.colliding(floor)) {
		block.color = 'red';
	} else block.color = 'blue';

	if (block.colliding(floor) > 60) {
		block.vel.y = -9;
	}
}
			</script>
			<script type="mie/p5" id="break-floor" horiz="">
let block, floor;

function setup() {
	new Canvas(60, 342);
	world.gravity.y = 10;
	
	block = new Sprite(30, 30);
	floor = new Sprite(30, 300, 60, 5, 'static');
}

function draw() {
	clear();
	if (block.collided(floor)) {
		floor.collider = 'dynamic';
	}
}
			</script>
		</div>
		<div id="page-6" class="page">
			<md id="md6-0">
				<h2 id="overlaps">Overlaps</h2>
				<p>Sprites collide by default but they can also overlap!</p>
				<p>By default sprites are drawn in the order they were created in.</p>
			</md>
			<script type="mie/p5" id="overlap" horiz="" lines="8" base-4="">
function setup() {
	new Canvas(180, 128);

	spriteA = new Sprite(80, 50);
	spriteB = new Sprite(105, 75);

	spriteA.overlaps(spriteB);
}

function draw() {
	clear();
}
			</script>
			<md id="md6-1">
				<h2 id="layer">Layer</h2>
				<p>You can change the draw order by editing a sprite's <code>.layer</code> property. Sprites with higher
					layer values get drawn on top of sprites with lower layer values.</p>
			</md>
			<script type="mie/p5" id="layer" horiz="" lines="8" base="4">
spriteA.layer = 2;
spriteA.text = 'Layer 2';

spriteB.layer = 1;
spriteB.text = 'Layer 1';
			</script>
			<md id="md6-2">
				<p>For detecting overlaps, use these functions inside the q5 <code>draw</code> function.</p>
				<p>On the first frame that a sprite overlaps with another sprite, the <code>overlaps</code> function
					returns true.</p>
				<p>While a sprite is overlapping with another sprite, the <code>overlapping</code> function returns the
					number of frames the overlap has occurred for.</p>
				<p>On the first frame after two sprites overlapped, the <code>overlapped</code> function returns true.
				</p>
				<p>Note that physical interactions between sprites, including collisions and overlaps, can't be properly
					detected when a
					sprite is teleported, its position is directly changed!</p>
				<p>The <code>remove</code> function deletes a sprite.</p>
			</md>
			<script type="mie/p5" id="collect-coin">
let player, coin;

function setup() {
	new Canvas(500, 100);

	coin = new Sprite(400, 50, 30);
	coin.color = 'yellow';
	player = new Sprite(50, 50);
}

function draw() {
	clear();
	player.moveTowards(mouse);
		
	if (player.overlaps(coin)) coin.remove();
}
			</script>
			<div class="break"></div>
			<md id="md6-3">
				<h2 id="try-it">Try it!</h2>
				<p>Try making the blue sprite change to red only if it's overlapping with the red sprite.</p>
			</md>
			<script type="mie/p5" id="Level-6-Challenge" lines="20" horiz="">
let sprite1, sprite2;

function setup() {
	new Canvas(100, 400);

	sprite1 = new Sprite(50, 50);
	sprite1.color = 'blue';

	sprite2 = new Sprite(50, 300);
	sprite2.color = 'red';
}

function draw() {
	clear();
	sprite1.moveTowards(mouse);

	
	
}
			</script>
			<div class="break"></div>
			<md id="md6-4">
				<h2 id="switch-between-overlaps-and-collides">Switch between overlaps and collides</h2>
				<p>When you set an overlap relationship between two sprites, they will no longer collide, but you can
					make them have a collision relationship again by using a collision function.</p>
				<p>In this example, pressing the space key temporarily allows the player to ghost through the wall.</p>
			</md>
			<script type="mie/p5" id="ghost-ability">
let player, wall;

function setup() {
	new Canvas(500, 100);

	wall = new Sprite(250, 50, 30, 400, 's');
	wall.color = 'purple';
	player = new Sprite(50, 50);
}

function draw() {
	clear();
	player.moveTowards(mouse);

	if (kb.pressing('space')) {
		player.overlaps(wall);
		player.color = 'purple';
	} else {
		player.collides(wall);
		player.color = 'orange';
	}
}

			</script>
		</div>
		<div id="page-7" class="page">
			<script type="mie/p5" base-5="" hide="">
let sprite;

function setup() {
	new Canvas(60, 80);

	sprite = new Sprite();
	sprite.h = 20;
}

function draw() {
	clear();
}
			</script>
			<script type="mie/p5" base-8="" hide="">
let sprite;

function setup() {
	new Canvas(500, 80);

	sprite = new Sprite();
	sprite.h = 20;
}

function draw() {
	clear();
}
			</script>
			<md id="md7-0">
				<h2 id="sprite-rotation">Sprite rotation</h2>
				<p>Directly changing the <code>rotation</code> property of a sprite will teleport it to the specified
					rotation angle.</p>
				<p>Don't teleport a sprite if you want it to physically interact with other sprites while it's rotating!
				</p>
			</md>
			<script type="mie/p5" id="rotation-(teleport)" base="5">
if (kb.pressing('space')) sprite.rotation = 90;
else sprite.rotation = 0;
			</script>
			<md id="md7-1">
				<p>All of the other rotation methods on this page work by changing the sprite's
					<code>rotationSpeed</code>.
				</p>
			</md>
			<script type="mie/p5" id="rotationSpeed" base="5">
sprite.rotationSpeed = 1;
			</script>
			<md id="md7-2">
				<p>Use the <code>rotate</code> function to rotate a sprite by an amount.</p>
				<p>Rotation speed can be defined separately or as an optional second parameter.</p>
			</md>
			<script type="mie/p5" id="rotate" base="5">
//                              (angle, rotationSpeed)
if (kb.presses('space')) sprite.rotate(15, 3);
			</script>
			<md id="md7-3">
				<p>Use the <code>rotateTo</code> function to rotate a sprite to an angle or to face a position. The
					<code>rotateMinTo</code> function changes the sign of the sprite's rotation speed if needed to
					rotate the sprite the minimum angular distance to face the destination angle. The "facing" angle, an
					optional third parameter, is the angle that the sprite should be at when facing the target position.
				</p>
				<p>Try changing the facing angle from 0 to 90 in the code example. Then when you click, the long side of
					the sprite will rotate to face the mouse.</p>
			</md>
			<div class="minis horiz">
				<script type="mie/p5" id="rotateTo-(an-angle)" base="5">
//                               (angle, rotationSpeed)
if (kb.presses('left')) sprite.rotateTo(-90, 5);
if (kb.presses('right')) sprite.rotateTo(0, 5);
				</script>
				<script type="mie/p5" id="rotateMinTo-(face-a-position)" base="8">
//                              (pos, speed, facing)
if (mouse.presses()) sprite.rotateMinTo(mouse, 5, 0);
				</script>
			</div>
			<md id="md7-4">
				<p>Use the <code>rotateTowards</code> function to rotate a sprite towards an angle or towards facing a
					position.</p>
				<p>The optional second parameter is the tracking speed, a percent of the distance the sprite moves on
					each frame to the target rotation angle, 0.1 (10%) by default.</p>
			</md>
			<script type="mie/p5" id="rotateTowards" base="5">
//           (position, tracking, facing)
sprite.rotateTowards(mouse, 0.1, 0);
			</script>
			<md id="md7-5">
				<p>Use the <code>offset</code> property to move the sprite's physics body relative to its center.</p>
				<p>When <code>sprite.debug</code> is true, the center of the sprite is marked with a small green
					crosshair. The center point is where the sprite's x and y coordinates are located. It is also the
					center of rotation.</p>
			</md>
			<script type="mie/p5" id="offset">
function setup() {
	new Canvas(500, 200);

	let flipper = new Sprite(250, 100, 200, 20, 'k');
	flipper.debug = true;
	flipper.rotationSpeed = 1;
	flipper.offset.x = 40;
}

function draw() {
	clear();
	if (mouse.presses()) new Sprite(mouse.x, mouse.y, 10);
}

			</script>
		</div>
		<div id="page-8" class="page">
			<md id="md8-0">
				<h2 id="scaling">Scaling</h2>
				<p>Changing <code>sprite.scale</code> will scale the sprite's collider and visual appearance by the
					specified amount.</p>
				<p>Press a number key to see the sprite scale uniformly by that amount.</p>
				<p>Click your mouse or touch tap to double the sprite's scale.</p>
				<p>Press "x" or "y" to scale the sprite in that direction by a random amount. But note that if the
					sprite gets scaled unevenly, the image will get distorted and stay that way even when scaled
					uniformly again.</p>
			</md>
			<script type="mie/p5" id="scaling">
let sprite;

function setup() {
	new Canvas(500, 200);

	sprite = new Sprite(250, 100, 90, 90);
	sprite.img = 'assets/square.webp';
	sprite.debug = true;
}

function draw() {
	clear();

	for (let i = 1; i < 10; i++) {
		if (kb.presses(i)) sprite.scale = i;
	}

	if (mouse.presses()) sprite.scale *= 2;
	if (kb.presses('x')) sprite.scale.x = random(0.1, 6);
	if (kb.presses('y')) sprite.scale.y = random(0.1, 6);

	if (kb.pressing('a')) sprite.img.scale.x = 10;
	else sprite.img.scale.x = 1;
}
			</script>
		</div>
		<div id="page-9" class="page">
			<md id="md9-0">
				<h2 id="physical-attributes">Physical attributes</h2>
				<p>Sprites have physical attributes that affect how they interact with the world. Take a look at the
					code examples to see these attributes in action.</p>
			</md>
			<script type="mie/p5" base-6="" hide="">
let sprite, floor;
function setup() {
	new Canvas(238, 100);
	world.gravity.y = 10;
	sprite = new Sprite(26, 0, 40, 40);
	floor = new Sprite(119, 88, 238, 5, 's');
	floor.rotation = 5;
}
function draw() {
	clear();
}
			</script>
			<script type="mie/p5" base-7="" hide="">
let sprite, floor;
function setup() {
	new Canvas(238, 100);
	world.gravity.y = 10;
	sprite = new Sprite(26, 0, 40);
	floor = new Sprite(119, 88, 238, 5, 's');
	floor.rotation = 5;
}
function draw() {
	clear();
}
			</script>
			<div class="minis">
				<script type="mie/p5" id="low-bounciness" base="7">
sprite.bounciness = 0.5;
				</script>
				<script type="mie/p5" id="full-bounciness" base="7">
sprite.bounciness = 1;
				</script>
			</div>
			<div class="minis">
				<script type="mie/p5" id="0-friction" base="6">
sprite.friction = 0;
				</script>
				<script type="mie/p5" id="high-friction" base="6">
sprite.friction = 10;
				</script>
				<script type="mie/p5" id="0-drag" base="6">
sprite.drag = 0;
				</script>
				<script type="mie/p5" id="high-drag" base="6">
sprite.drag = 10;
				</script>
			</div>
			<div class="minis">
				<script type="mie/p5" id="low-rotationDrag" base="7">
sprite.rotationDrag = 1;
				</script>
				<script type="mie/p5" id="high-rotationDrag" base="7">
sprite.rotationDrag = 5;
				</script>
				<script type="mie/p5" id="no-rotationLock" base="7">
sprite.rotationLock=false
				</script>
				<script type="mie/p5" id="with-rotationLock" base="7">
sprite.rotationLock =true
				</script>
			</div>
			<div class="break"></div>
			<div class="minis horiz">
				<md id="md9-1">
					<h2 id="mass">Mass</h2>
					<p>The larger the sprite, the more mass it has by default. When a sprite's size is initially
						defined, its <code>mass</code> will be calculated.</p>
					<p>But in the real world, stretching or squishing an object doesn't change its mass, so in p5play
						changing a sprite's size doesn't change its mass either. To recalculate a sprite's mass after
						changing its size, use the <code>resetMass</code> function.</p>
				</md>
				<md id="md9-2">
					<h2 id="try-it">Try it!</h2>
					<p>This code example shows how sprites of different sizes can balance on a seesaw if their mass is
						set to the same value. Try changing the mass of one of the sprites.</p>
				</md>
			</div>
			<script type="mie/p5" id="mass" lines="15">
let platform, pin, spriteA, spriteB;

function setup() {
	new Canvas(300, 100);
	world.gravity.y = 10;

	platform = new Sprite(150, 88, 232, 5);
	pin = new Sprite(150, 93, 5, 's');

	spriteA = new Sprite(50, 0, 80, 40);
	spriteA.mass = 2;

	spriteB = new Sprite(250, 0, 20, 40);
	spriteB.mass = 2;
}

function draw() {
	clear();
}
			</script>
			<div class="break"></div>
			<md id="md9-3">
				<h2 id="planck">planck</h2>
				<p>p5play uses planck.js, a JS port of the Box2D physics engine. It generates realistic looking
					interactions at a good rate of performance, but it also has some limitations you should be aware of.
				</p>
				<p>In this code example the ball has a <code>bounciness</code> of 1, so each time the ball bounces it
					should return to its starting position. However, due to a bug in planck, the ball bounces
					incrementally higher each time it hits the ground.</p>
			</md>
			<script type="mie/p5" id="full-bounce-error" lines="10" horiz="">
let ball, ground;
function setup() {
	new Canvas(32, 192);
	world.gravity.y = 10;

	ball = new Sprite(16, 100, 8);
	ball.bounciness = 1;

	ground = new Sprite(16, 184, 32, 16, 's');
}

function draw() {
	background(0);

	fill(100);
	for (let i = 0; i < width / 32; i++) {
		for (let j = 0; j < height / 32; j++) {
			rect(i * 32, j * 32, 32, 32);
		}
	}
}
			</script>
			<md id="md9-4">
				<p>This full bounce interaction is impossible in real life, but could be an important element in a video
					game.</p>
				<p>The <code>bounciness</code> bug is most noticeable when a collider bounces off a flat surface, like
					in these examples.</p>
				<p>Here's a workaround that overrides the ball's y velocity after it collides with the ground.</p>
			</md>
			<script type="mie/p5" id="full-bounce-workaround" horiz="">
let ball, ground;
function setup() {
	new Canvas(32, 192);
	world.gravity.y = 10;

	ball = new Sprite(16, 100, 8);
	ball.bounciness = 1;

	ground = new Sprite(16, 184, 32, 16, 's');
}

function draw() {
	clear();

	if (ball.collided(ground)) {
		ball.vel.y = -4.8;
	}
}
			</script>
			<md id="md9-5">
				<p>In this example the block's color is red when it is colliding with the moving platform. Although you
					might expect the block to stay red while being lifted by the platform, it blinks between red and
					blue.</p>
				<p>In real life when a person gets on an elevator and it rises, we would say that person was colliding
					with the elevator floor.</p>
				<p>In planck however, when a collider is displaced by another collider, they constantly collide and
					separate from each other.</p>
				<p>If you're trying to make a platformer game, <code>colliding</code> is not a reliable way to check if
					a sprite is standing on a platform. Check out my <a href="https://openprocessing.org/sketch/1869796"
						target="_blank">platformer demo</a>.</p>
			</md>
			<script type="mie/p5" id="displacement" horiz="">
let block, platform;

function setup() {
	new Canvas(60, 400);
	world.gravity.y = 10;

	block = new Sprite(30, 30);
	platform = new Sprite(30, 200, 60, 5, 'k');
	platform.color = 'red';
}

function draw() {
	clear();
	platform.vel.y = cos(frameCount * 2.2) * 6;

	if (block.colliding(platform)) {
		block.color = 'red';
	} else {
		block.color = 'blue';
	}
}

			</script>
		</div>
		<div id="page-10" class="page">
			<md id="md10-0">
				<h2 id="advanced-movement">Advanced Movement</h2>
				<p><code>move</code> functions are imperative, they override a sprite's velocities. But what if you want
					a sprite to respect other forces acting on it, such as gravity?</p>
				<p>A bearing is the direction that needs to be followed to reach a destination. Changing a sprite's
					bearing won't imperatively change its movement direction.</p>
				<p>Use <code>applyForce</code> with one input parameter, the amount of force, to have the force be
					applied at the sprite's <code>bearing</code> angle.</p>
				<p>In this example, the drone has to overcome the force of gravity to fly. Make the drone fly, then let
					it fall, when upward force is applied to the drone again it'll gradually stop falling and start to
					fly!</p>
			</md>
			<script type="mie/p5" id="applyForce" horiz="">
let drone, floor;

function setup() {
	new Canvas(100, 500);
	world.gravity.y = 4;

	drone = new Sprite(50, 0, 40, 10);
	
	floor = new Sprite(50, 498, 100, 6, 's');
}

function draw() {
	background(16);

	if (mouse.pressing()) {
		drone.bearing = -90;
		drone.applyForce(6);
	}
}
			</script>
			<md id="md10-1">
				<p>The <code>applyForceScaled</code> function multiplies the force applied to the sprite by its mass.
				</p>
				<p>You can use this function to give sprites their own gravity!</p>
				<p>Both force functions can accept force as separate x and y components or as an amount, provided you
					set the sprite's <code>bearing</code>.</p>
				<p>By default, force is applied to the sprite's center of mass. But the force functions can also accept
					a last input parameter, a position object with x and y properties that specifies the relative
					position of where force will be applied on the sprite.</p>
			</md>
			<script type="mie/p5" id="applyForceScaled" horiz="">
let s0, s1;
function setup() {
  new Canvas(100, 288);
  s0 = new Sprite(51, 252, 20, 20);
	s1 = new Sprite(49, 32, 20, 20);
	new Sprite(50, 4, 100, 8, 's');
  new Sprite(50, 284, 100, 8, 's');
}

function draw() {
  background(16);
	//                 (x,  y)
	s0.applyForceScaled(0, -10);
	s1.applyForceScaled(0, 10);
}
      </script>
			<md id="md10-2">
				<p>Use the <code>attractTo</code> function to attract the sprite to a position by applying force. The
					position can be given as an object with x and y properties or as separate x and y parameters.</p>
				<p>This example shows an electron orbiting the nucleus of an atom. (Note this visualization isn't
					realistic based on current scientific understanding, but it looks cool!)</p>
				<p>Note that the advanced movement functions shown on this page will not wake <a href="./world.html"
						target="_blank">sleeping sprites</a>!</p>
			</md>
			<script type="mie/p5" id="attractTo">
let nucleus, electron;

function setup() {
	new Canvas(500, 200);
	nucleus = new Sprite(250, 100, 45);
	electron = new Sprite(150, 100, 10);
	electron.vel.y = 5;
}

function draw() {
	background(16, 10);
	//               (position, force)
	electron.attractTo(nucleus, 5);
}
			</script>
			<md id="md10-3">
				<p>Torque is the force that causes rotation. Use <code>applyTorque</code> to non-imperatively affect the
					sprite's rotation.</p>
				<p>In this example, the robot rolls slower going uphill than it does going downhill.</p>
			</md>
			<script type="mie/p5" id="applyTorque">
let robot, floor1, floor2;

function setup() {
	new Canvas(500, 250);
	world.gravity.y = 10;

	robot = new Sprite(250, 0, 50);
	robot.debug = true;

	floor1 = new Sprite(400, 100, 500, 5, 's');
	floor1.rotation = -10;
	floor2 = new Sprite(890, 100, 500, 5, 's');
	floor2.rotation = 10;
}

function draw() {
	background(16);
	
	robot.applyTorque(3);

	camera.pos = robot.pos;
}
			</script>
		</div>
		<div id="page-11" class="page">
			<md id="md11-0">
				<h2 id="chain-colliders">Chain Colliders</h2>
				<p>There are three different chain modes: vertex, distance, and line.</p>
				<p>To use vertex mode, provide the Sprite constructor with an array of vertex arrays. Each vertex array
					should contain [x, y] coordinates. In these code examples the sprite's (x, y) position is
					highlighted by a small black square.</p>
				<p>Try changing the vertexes of the chain sprite in the code example to make the ball stay on the floor!
				</p>
			</md>
			<script type="mie/p5" id="vertex-mode" lines="12">
let floor, ball;

function setup() {
	new Canvas(500, 200);
	world.gravity.y = 10;

	//                ([vertex0, vertex1, vertex2, ...])
	floor = new Sprite([[20, 60], [200, 140], [450, 180]]);
	floor.collider = 'static';

	ball = new Sprite(40, 0, 20);
}

function draw() {
	clear();
	rect(floor.x - 2, floor.y - 2, 4, 4);
}
			</script>
			<md id="md11-1">
				<p>To use distance mode, provide the Sprite constructor an (x, y) position and an array of distance
					arrays. These arrays should contain [x, y] distances relative to the previous vertex. The (x, y)
					position will be the first vertex in the chain.</p>
				<p>Distance mode is best for creating super long chains.</p>
				<p>Try adding 5 distances to make the ground roll up and down on a rocky ground chain.</p>
			</md>
			<script type="mie/p5" id="distance-mode" lines="9">
function setup() {
	new Canvas(500, 100);
	world.gravity.y = 10;

	//        ( x,  y, [distance0, distance1, ...])
	new Sprite(30, 50, [[60, 20], [90, -9], [90, 9]], 's');

	new Sprite(40, 0, 20);
}
	
function draw() {
	clear();
	rect(allSprites[0].x - 2, allSprites[0].y - 2, 4, 4);
}
			</script>

			<md id="md11-2">
				<p>To use line mode, provide the Sprite constructor an (x,y) position and a list of line lengths and
					angles. Each angle is relative to the previous line's angle.</p>
				<p>It's best to use line mode for small and/or symmetrical chains.</p>
				<p>Note that the line mode chain's (x, y) position is located at the average of all its vertices, which
					may not be a point on the chain.</p>
				<p>Try changing the lengths of these lines and their angles!</p>
			</md>
			<script type="mie/p5" id="line-mode" lines="9">
function setup() {
	new Canvas(500, 200);
	world.gravity.y = 10;

	//        (  x,   y, [length0, angle0, length1, ...])
	new Sprite(250, 100, [50, 20, 50, -20, 50, -20], 's');

	new Sprite(200, 0, 20);
}
	
function draw() {
	clear();
	rect(allSprites[0].x - 2, allSprites[0].y - 2, 4, 4);
}
			</script>
		</div>
		<div id="page-12" class="page">
			<md id="md12-0">
				<h2 id="polygon-colliders">Polygon Colliders</h2>
				<p>Regular polygons can be created by providing the Sprite constructor with a side length and the name
					of the polygon.</p>
				<p>Here are the names you can use: triangle, square, pentagon, hexagon, septagon, octagon, enneagon,
					decagon, hendecagon, and dodecagon.</p>
			</md>
			<script type="mie/p5" id="pentagon" lines="6">
function setup() {
	new Canvas(500, 100);

	//        ( x,  y, sideLength, polygonName)
	new Sprite(250, 50, 50, 'pentagon');
}
	
function draw() {
	clear();
}
			</script>
			<md id="md12-1">
				<p>If the start and end of a chain is at the same point and the resulting shape is convex, it
					automatically becomes a polygon!</p>
			</md>
			<script type="mie/p5" id="irregular-polygon:-vertex-mode" lines="5">
function setup() {
	new Canvas(500, 100);

	new Sprite([[8, 8], [140, 92], [300, 40], [8, 8]]);
}

function draw() {
	clear();
}
			</script>
			<md id="md12-2">
				<p>You can force a convex polygon to be a chain by setting <code>sprite.shape = 'chain'</code></p>
			</md>
			<script type="mie/p5" id="box-chain" lines="6" horiz="">
function setup() {
	new Canvas(150, 100);

	let s = new Sprite(75, 50, 100, 60);
	s.shape = 'chain';
}
	
function draw() {
	clear();
}
			</script>
			<md id="md12-3">
				<p>Any polygon or chain with a closed shape is center positioned.</p>
			</md>
			<script type="mie/p5" id="irregular-polygon:-distance-mode" lines="9" horiz="">
function setup() {
	new Canvas(250, 100);

	new Sprite(125, 50, [
		[100, 40],
		[-100, 40],
		[0, -80]
	]);
}

function draw() {
	clear();
}
			</script>
			<md id="md12-4">
				<p>Here's the code for making a regular star with five points.</p>
				<p>Note that because the star is a concave shape it can't have a polygon collider.</p>
			</md>
			<script type="mie/p5" id="star" lines="6">
function setup() {
	new Canvas(500, 160);

	//        ( x,  y, [l0, a0, l1, a1, repeat])
	new Sprite(250, 80, [50, -72, 50, 144, 5]);
}

function draw() {
	clear();
}
			</script>
			<md id="md12-5">
				<p>Now you can see how the tumbler demo on the p5play homepage was made!</p>
				<p>Closed chains are empty on the inside and they can act as a container for many smaller sprites.</p>
			</md>
			<script type="mie/p5" id="p5play-logo" lines="8">
function setup() {
	new Canvas(500, 180);
	world.gravity.y = 10;

	new Sprite(250, 90, [40, 72, 40, -72, 40, 72, 5], 's');

	new Sprite(251, 50, 20, 'pentagon');
}

function draw() {
	clear();
}
			</script>
			<md id="md12-6">
				<p>Note that closed chain colliders aren't so good at being dynamic colliders.</p>
				<p>This is a limitation of the Box2D physics engine that p5play uses. See the "Combo Colliders" page to
					learn how to create concave colliders from multiple convex colliders.</p>
			</md>
			<script type="mie/p5" id="concave-chain-colliders" lines="11">
function setup() {
	new Canvas(500, 100);
	world.gravity.y = 10;

	new Sprite([
		[200, 0],
		[300, 0],
		[300, 50],
		[280, 20],
		[200, 0]
	]);

	new Sprite(250, 90, 500, 10, 's');
}

function draw() {
	clear();
}
			</script>
		</div>
		<div id="page-13" class="page">
			<div class="minis horiz">
				<md id="md13-0">
					<h2 id="combo-colliders">Combo Colliders</h2>
					<p>By using the <code>addCollider</code> function you can add multiple colliders to a sprite. It
						supports the same input arguments as the Sprite constructor, except the first two parameters are
						x and y offsets from the sprite's position.</p>
					<p>But only use this feature when it's really necessary for gameplay! Usually if something requires
						a lot of colliders, like the walls of a maze, you should just create multiple sprites, each with
						their own collider. Also, even if a sprite's image is complex, typically a box or circle will be
						just fine for physics interactions, especially for small sprites.</p>
					<p>Yet sometimes, you will truly need to create a sprite with multiple colliders. For example, if
						you want to model a pinball flipper!</p>
					<p>Note that adding a collider to a sprite will automatically recalculate the sprite's mass.</p>
				</md>
				<md id="md13-1">
					<h2 id="combo-sensors">Combo Sensors</h2>
					<p>Overlap sensors determine if a sprite overlaps with another sprite.</p>
					<p>By default when an overlap checking method is used, and the sprite has no sensors, the
						<code>addDefaultSensors</code> function is used behind the scenes to create sensors for each of
						the sprite's colliders.
					</p>
					<p>You can add additional sensors to a sprite by using the <code>addSensor</code> function.</p>
				</md>
			</div>
			<script type="mie/p5" id="pinball-flipper" horiz="">
let ball, flipper;

function setup() {
	new Canvas(180, 500);
	world.gravity.y = 10;

	ball = new Sprite(100, -20, 30);

	flipper = new Sprite(160, 400, [
		[0, -25],
		[-100, 12.5],
		[0, 25],
		[100, 12.5],
		[0, -25]
	], 'k');

	flipper.addCollider(-60, 0, 25);
	flipper.addCollider(40, 0, 50);
	
	flipper.offset.x = -40;
	flipper.rotation = -20;
	flipper.debug = true;
}

function draw() {
	background(16);

	if (mouse.presses()) {
		flipper.rotateTo(20, 8);
	}
	if (mouse.released()) {
		flipper.rotateTo(-20, -8);
	}
	if (frameCount % 100 == 0) {
		ball.life = 200;
		let x = random(50, 140);
		ball = new Sprite(x, -100, 30);
	}
}
			</script>
		</div>
		<div id="page-14" class="page">
			<div class="minis horiz">
				<md id="md14-0">
					<h2 id="custom-draw">Custom Draw</h2>
					<p>Sometimes you won't be able to use pre-drawn animations to get the kind of visual effect you want
						for a sprite in motion.</p>
					<p>Fortunately, you can customize the sprite's <code>draw</code> function to make it display
						anything you want!</p>
					<p>Note that inside the sprite's draw function the center of the sprite is translated to position
						(0, 0).</p>
					<p>This code example rotates the sprite's ellipse to the direction it's moving and makes the ellipse
						stretch in that direction proportional to its speed. Kind of complicated!</p>
				</md>
				<md id="md14-1">
					<h2 id="custom-update">Custom Update</h2>
					<p>A sprite's <code>update</code> function runs at the end of the q5 <code>draw</code> loop by
						default. It updates the sprite's animation (if it has one) and mouse event tracking.</p>
					<p>Thanks to some behind the scenes magic, overriding the function will not replace the default
						behavior, but allows you to add to it.</p>
				</md>
			</div>
			<script type="mie/p5" id="stretchy" lines="22">
function setup() {
	new Canvas(500, 200);

	let face = loadImage('assets/face.webp');
	let stretchy = new Sprite();
	
	stretchy.draw = () => {
		fill(237, 205, 0);

		push();
		rotate(stretchy.direction);
		ellipse(0, 0, 100 + stretchy.speed, 100 - stretchy.speed);
		pop();

		image(face, stretchy.vel.x * 2, stretchy.vel.y * 2);
	};

	stretchy.update = () => {
		stretchy.moveTowards(mouse, 0.07);
	};
}

function draw() {
	clear();
}
			</script>
		</div>
		<div id="page-15" class="page">
			<md id="md15-0">
				<h2 id="movement-sequencing">Movement Sequencing</h2>
				<p>These examples use a <code>Turtle</code> sprite which is green and shaped like a triangle for that
					classic turtle programming look. Unlike regular sprites, the turtle's direction is always the same
					as its rotation.</p>
				<p>You can use the <code>await</code> keyword inside an <code>async</code> function to wait for a
					movement to finish before continuing with the next movement. This is useful for making a sprite move
					in a sequence.</p>
				<p>The <code>delay</code> function can be used to wait for a specified number of milliseconds. 1000
					milliseconds is equal to 1 second!</p>
			</md>
			<script type="mie/p5" id="square-sequence" horiz="" lines="15">
let turtle;

function setup() {
	new Canvas(160, 160);
	turtle = new Turtle(30);

	squareSequence();
}

async function squareSequence() {
	await turtle.move(100);
	await turtle.rotate(90);
  await delay(1000);
	squareSequence();
}

function draw() {
	clear();
}
			</script>
			<md id="md15-1">
				<p>The <code>move</code>, <code>moveTo</code>, <code>rotate</code>, and <code>rotateTo</code> functions
					all return a <code>Promise</code> that resolves to true when the movement is finished.</p>
				<p>But, if the sprite's movement is interrupted by a new movement or a collision that significantly
					changes the sprite's trajectory, the promise will resolve to false.</p>
			</md>
			<script type="mie/p5" id="random-sequence" horiz="" lines="17">
let turtle, ball;

function setup() {
	new Canvas(160, 304);
	turtle = new Turtle(30);
	ball = new Sprite(80, 152, 50);

	randomSequence();
}

async function randomSequence() {
	let x = random(0, width);
	let y = random(0, height);
	await turtle.rotateTo(x, y, 5);
	await turtle.moveTo(x, y, 3);
	randomSequence();
}

function draw() {
	clear();
}
			</script>
			<md id="md15-2">
				<p>If you want a sprite to follow another sprite, you may be tempted to use <code>moveTo</code>
					repeatedly, without waiting for the sprite to reach its destination. But for better performance, try
					using the <code>angleTo</code> function, which gets the angle between a sprite and a position. This
					angle can be used to change the direction that the sprite moves in.</p>
				<p>In this example, the q5 <a href="https://p5js.org/reference/p5/dist" target="_blank"><code>dist</code></a>
					function is used to calculate the distance between the
					player and its ally.</p>
			</md>
			<script type="mie/p5" base-8="" hidden="">
let player, ally;

function setup() {
	new Canvas(500, 100);
	player = new Sprite(400, 50, 20);
	ally = new Sprite(200, 50, 20, 20, 'n');
}

function draw() {
	clear();
}
			</script>
			<script type="mie/p5" id="angleTo" base="8">
player.moveTowards(mouse);

let distance = dist(player.x, player.y, ally.x, ally.y);

if (distance > 40) {
	ally.direction = ally.angleTo(player);
	ally.speed = 2;
} else if (distance < 30) {
	ally.speed = 0;
}
			</script>
		</div>

		<div class="break"></div>
		<div id="toc">
			<a id="prevPage" class="navLink">Previous Page</a>
			<div id="pageNav" class="submenu">
				<a data-page="0" href="sprite.html?page=0">Basic Properties</a>
				<a data-page="1" href="sprite.html?page=1">Physics</a>
				<a data-page="2" href="sprite.html?page=2">Sprites with an Image</a>
				<a data-page="3" href="sprite.html?page=3">Movement</a>
				<a data-page="4" href="sprite.html?page=4">Sprite Constructor</a>
				<a data-page="5" href="sprite.html?page=5">Collisions</a>
				<a data-page="6" href="sprite.html?page=6">Overlaps</a>
				<a data-page="7" href="sprite.html?page=7">Rotation</a>
				<a data-page="8" href="sprite.html?page=8">Scaling</a>
				<a data-page="9" href="sprite.html?page=9">Physical Attributes</a>
				<a data-page="10" href="sprite.html?page=10">Advanced Movement</a>
				<a data-page="11" href="sprite.html?page=11">Chains</a>
				<a data-page="12" href="sprite.html?page=12">Polygons</a>
				<a data-page="13" href="sprite.html?page=13">Combo Colliders</a>
				<a data-page="14" href="sprite.html?page=14">Draw and Update</a>
				<a data-page="15" href="sprite.html?page=15">Movement Sequencing</a>
			</div>
			<a id="nextPage" class="navLink">Next Page</a>
		</div>
		<div class="break"></div>
		<footer id="credits" class="text-small">Created by Quinton Ashley (@quinton-ashley) Copyright 2022-2024</footer>
	</article>

	<!-- <script src="https://cdn.jsdelivr.net/npm/p5@1/lib/p5.min.js"></script> -->
	<script src="/v3/q5.min.js"></script>
	<script src="/v3/planck.min.js"></script>
	<script src="/v3/p5play.min.js"></script>
	<script>
		window.mie = { autoLoad: false };

	</script>
	<script src="/learn/mie.js"></script>
	<script src="/learn/learn.js"></script>
	<script src="/account/account.js"></script>
</body>

</html>
